<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éœ“è™¹æ˜Ÿæˆ˜ï¼šç»ˆæè¿›åŒ–ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD æ ·å¼ */
        .top-bar {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-weight: 900;
            text-shadow: 0 0 10px currentColor;
            font-size: 20px;
            gap: 20px;
        }
        .hud-item { display: flex; flex-direction: column; align-items: center; min-width: 200px; }
        .bar-frame {
            width: 200px; height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5);
            margin-top: 5px;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
        }
        .fill-bar { height: 100%; transition: width 0.1s; }
        
        /* è¿å‡»æ˜¾ç¤º */
        #combo-display {
            position: absolute;
            top: 80px; left: 20px;
            font-size: 32px;
            font-weight: 900;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            pointer-events: none;
            display: none;
        }
        
        /* èƒ½é‡æ¡ */
        #energy-bar {
            background: linear-gradient(90deg, #ffff00, #ff8800);
            box-shadow: 0 0 10px #ffff00;
        }
        
        #boss-hud {
            position: absolute; top: 80px; width: 100%;
            display: none; align-items: center; flex-direction: column;
        }
        #boss-name { font-size: 28px; color: #ff0055; text-shadow: 0 0 15px red; letter-spacing: 5px; margin-bottom: 5px; }

        /* æ­¦å™¨æŒ‡ç¤ºå™¨ */
        #weapon-indicator {
            position: absolute; bottom: 30px; left: 30px;
            font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px cyan;
        }

        /* å±å¹•æ–‡å­— */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        h1 {
            font-size: 60px; margin: 0 0 20px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 5px;
        }
        button {
            background: transparent; color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 50px; font-size: 24px;
            cursor: pointer; transition: 0.3s;
            text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 15px #00ffff;
        }
        button:hover { background: #00ffff; color: black; transform: scale(1.1); }
        .hidden { display: none !important; }
        
        /* æç¤ºåŠ¨ç”» */
        @keyframes flash { 0%{opacity:1} 50%{opacity:0.2} 100%{opacity:1} }
        .warning-text { 
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 100px; color: #ff0000; font-weight: 900;
            animation: flash 0.3s infinite; display: none; letter-spacing: 20px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="hud-item" style="color:#00ffff; align-items: flex-start;">
                <div id="score-txt">SCORE: 0</div>
                <div id="level-txt" style="font-size:14px; opacity:0.8">SECTOR 1</div>
            </div>
            <div class="hud-item">
                <div style="color: #00ff00">SHIELD INTEGRITY</div>
                <div class="bar-frame"><div id="hp-bar" class="fill-bar" style="width:100%; background:#00ff00; box-shadow: 0 0 10px #00ff00;"></div></div>
            </div>
            <div class="hud-item">
                <div style="color: #ffff00">ENERGY</div>
                <div class="bar-frame"><div id="energy-bar" class="fill-bar" style="width:100%;"></div></div>
            </div>
        </div>
        
        <div id="combo-display">COMBO x1</div>

        <div id="boss-hud">
            <div id="boss-name">WARNING</div>
            <div class="bar-frame" style="width: 60%; height: 20px; border-color: #ff0055;">
                <div id="boss-hp" class="fill-bar" style="width: 100%; background: #ff0055; box-shadow: 0 0 20px #ff0055;"></div>
            </div>
        </div>

        <div id="weapon-indicator">WEAPON: SPREAD</div>
        <div id="emp-indicator" style="position: absolute; top: 110px; left: 20px; font-size: 16px; font-weight: bold; display: none;">EMP: 0</div>
        <div id="warning-msg" class="warning-text">WARNING</div>

        <div id="start-screen" class="screen-overlay">
            <h1>éœ“è™¹æ˜Ÿæˆ˜<span style="font-size:30px; display:block; text-align:center; letter-spacing:10px; margin-top:10px; color:white; -webkit-text-fill-color:white;">ç»ˆæè¿›åŒ–</span></h1>
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; margin-bottom:40px; text-align:center;">
                <div><span style="color:#00ffff; font-size:30px;">â—</span><br>æ•£å¼¹ (1)</div>
                <div><span style="color:#ff00ff; font-size:30px;">â—</span><br>å¯¼å¼¹ (2)</div>
                <div><span style="color:#4488ff; font-size:30px;">â—</span><br>æ¿€å…‰ (3)</div>
            </div>
            <div style="display:flex; gap:20px; margin-bottom:40px;">
                <button class="difficulty-btn" data-difficulty="easy">ç®€å•</button>
                <button class="difficulty-btn" data-difficulty="normal" style="background:#00ffff; color:black;">æ™®é€š</button>
                <button class="difficulty-btn" data-difficulty="hard">å›°éš¾</button>
            </div>
            <div style="display:flex; gap:20px; justify-content:center; flex-wrap:wrap;">
                <button id="start-btn">å¯åŠ¨å¼•æ“</button>
                <button id="leaderboard-btn-start" style="background:transparent; border:2px solid #00ffff; color:#00ffff;">æ’è¡Œæ¦œ</button>
                <button id="achievements-btn-start" style="background:transparent; border:2px solid #ffd700; color:#ffd700;">æˆå°±</button>
                <button id="guide-btn-start" style="background:transparent; border:2px solid #00ff00; color:#00ff00;">å…¥å‘æŒ‡å—</button>
            </div>
        </div>

        <div id="game-over-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:red; color:red; text-shadow: 0 0 30px red;">é€šè®¯ä¸­æ–­</h1>
            <p id="final-score" style="font-size:30px; margin-bottom:10px;">æœ€ç»ˆå¾—åˆ†: 0</p>
            <p id="final-time" style="font-size:20px; margin-bottom:30px; color:#888;">æ¸¸æˆæ—¶é•¿: 0:00</p>
            <div style="display:flex; gap:20px; justify-content:center;">
                <button id="restart-btn">é‡å¯ç³»ç»Ÿ</button>
                <button id="leaderboard-btn-gameover" style="background:transparent; border:2px solid #00ffff; color:#00ffff;">æ’è¡Œæ¦œ</button>
            </div>
        </div>

        <div id="leaderboard-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:#00ffff; color:#00ffff; text-shadow: 0 0 30px #00ffff;">æ’è¡Œæ¦œ</h1>
            <div id="leaderboard-list" style="width:80%; max-width:800px; max-height:60vh; overflow-y:auto; margin-bottom:30px;"></div>
            <div style="display:flex; gap:20px; justify-content:center;">
                <button id="leaderboard-back-btn">è¿”å›</button>
                <button id="leaderboard-clear-btn" style="background:transparent; border:2px solid #ff0000; color:#ff0000;">æ¸…ç©ºè®°å½•</button>
            </div>
        </div>

        <div id="achievements-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:#ffd700; color:#ffd700; text-shadow: 0 0 30px #ffd700;">æˆå°±æ®¿å ‚</h1>
            <div id="achievements-list" style="width:80%; max-width:800px; max-height:60vh; overflow-y:auto; margin-bottom:30px;"></div>
            <div style="display:flex; gap:20px; justify-content:center;">
                <button id="achievements-back-btn">è¿”å›</button>
            </div>
        </div>

        <div id="guide-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:#00ff00; color:#00ff00; text-shadow: 0 0 30px #00ff00;">ğŸš€ éœ“è™¹æ˜Ÿæˆ˜å…¥å‘æŒ‡å—</h1>
            <div id="guide-content" style="width:85%; max-width:900px; max-height:65vh; overflow-y:auto; text-align:left; font-size:14px; line-height:1.8;">
                
                <div style="background:rgba(0,255,255,0.1); border-left:4px solid #00ffff; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#00ffff; margin-top:0;">ğŸ® åŸºç¡€æ“ä½œ</h3>
                    <p><strong>é¼ æ ‡ç§»åŠ¨</strong> - æ§åˆ¶æˆ˜æœºä½ç½®</p>
                    <p><strong>è‡ªåŠ¨å°„å‡»</strong> - æˆ˜æœºè‡ªåŠ¨å‘æ­£ä¸Šæ–¹å°„å‡»</p>
                    <p><strong>æ•°å­—é”®1-8</strong> - åˆ‡æ¢æ­¦å™¨ï¼ˆæ‹¾å–å¯¹åº”èƒ½é‡çƒåè§£é”ï¼‰</p>
                    <p><strong style="color:#ff0000; font-size:16px; text-shadow: 0 0 10px #ff0000;">âš ï¸ Eé”® - ä½¿ç”¨EMPæŠ€èƒ½ï¼ˆéœ€æ‹¾å–èƒ½é‡çƒEå……èƒ½ï¼‰</strong></p>
                </div>

                <div style="background:rgba(255,0,255,0.1); border-left:4px solid #ff00ff; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#ff00ff; margin-top:0;">ğŸ”« æ­¦å™¨ç³»ç»Ÿ</h3>
                    <p><span style="color:#00ffff;">â— æ•£å¼¹(1)</span> - æ‰‡å½¢æ•£å°„ï¼Œé€‚åˆæ¸…ç†å¤§é‡æ•Œäºº</p>
                    <p><span style="color:#ff00ff;">â— å¯¼å¼¹(2)</span> - è‡ªåŠ¨è¿½è¸ªï¼Œå¯¹å•ä½“ä¼¤å®³é«˜</p>
                    <p><span style="color:#4488ff;">â— æ¿€å…‰(3)</span> - é«˜é€Ÿç›´çº¿ï¼Œç©¿é€æ•Œäºº</p>
                    <p><span style="color:#ff8800;">â— ç«ç„°å–·å°„å™¨(4)</span> - è¿‘è·ç¦»é«˜ä¼¤å®³</p>
                    <p><span style="color:#00ff88;">â— æ—¶é—´å‡é€Ÿ(6)</span> - å‡ç¼“æ•Œäººé€Ÿåº¦</p>
                    <p><span style="color:#ffff00;">â— åˆ†è£‚å¼¹(7)</span> - å‡»ä¸­ååˆ†è£‚æˆå¤šä¸ªå­å¼¹</p>
                    <p><span style="color:#4488ff;">â— æŠ¤ç›¾(8)</span> - æŠµæŒ¡ä¼¤å®³ï¼ŒæŒ‰8å¼€å¯/å…³é—­</p>
                    <p><span style="color:#ff0000;">â— è¶…èƒ½æ¿€å…‰(9)</span> - ç§’æ€éBosså•ä½</p>
                    <p style="color:#ffff00; margin-top:10px;">ğŸ’¡ æ‹¾å–æ–°æ­¦å™¨æ—¶ä¼šè‡ªåŠ¨å‡çº§ï¼æ»¡çº§æ­¦å™¨æ‹¾å–åè·å¾—ä¼¤å®³åŠ æˆï¼</p>
                </div>

                <div style="background:rgba(136,68,255,0.1); border-left:4px solid #8844ff; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#8844ff; margin-top:0;">âš¡ EMPæŠ€èƒ½ç³»ç»Ÿ</h3>
                    <p>EMPæ˜¯ç‹¬ç«‹æŠ€èƒ½ï¼Œ<strong>ä¸æ¶ˆè€—èƒ½é‡</strong>ï¼</p>
                    <p>æ‹¾å–<span style="color:#8844ff;">èƒ½é‡çƒE</span>å¯å¢åŠ EMPä½¿ç”¨æ¬¡æ•°</p>
                    <p>ä½¿ç”¨EMPæ—¶è‡ªåŠ¨å¼€å¯<strong>5ç§’æŠ¤ç›¾</strong></p>
                    <p>EMPæœ‰èŒƒå›´æŒ‡ç¤ºåœˆï¼Œå»¶è¿Ÿåçˆ†ç‚¸é€ æˆèŒƒå›´ä¼¤å®³</p>
                </div>

                <div style="background:rgba(255,215,0,0.1); border-left:4px solid #ffd700; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#ffd700; margin-top:0;">ğŸ¯ é“å…·è¯´æ˜</h3>
                    <p><span style="color:#00ff00;">H</span> - ç”Ÿå‘½æ¢å¤ +30HP</p>
                    <p><span style="color:#8844ff;">E</span> - EMPå……èƒ½ +1æ¬¡</p>
                    <p><span style="color:#00ffff;">W</span> - æ•£å¼¹æ­¦å™¨/å‡çº§</p>
                    <p><span style="color:#ff00ff;">M</span> - å¯¼å¼¹æ­¦å™¨/å‡çº§</p>
                    <p><span style="color:#4488ff;">L</span> - æ¿€å…‰æ­¦å™¨/å‡çº§</p>
                    <p><span style="color:#ff8800;">F</span> - ç«ç„°å–·å°„å™¨/å‡çº§</p>
                    <p><span style="color:#00ff88;">T</span> - æ—¶é—´å‡é€Ÿ/å‡çº§</p>
                    <p><span style="color:#ffff00;">S</span> - åˆ†è£‚å¼¹/å‡çº§</p>
                    <p><span style="color:#4488ff;">G</span> - æŠ¤ç›¾/å‡çº§</p>
                </div>

                <div style="background:rgba(255,0,0,0.1); border-left:4px solid #ff0000; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#ff0000; margin-top:0;">ğŸ‘¾ æ•Œäººç§ç±»</h3>
                    <p><strong>åŸºç¡€å‹</strong> - ç›´çº¿å‘ä¸‹ç§»åŠ¨</p>
                    <p><strong>å°„å‡»å‹</strong> - ä¼šå‘å°„å­å¼¹</p>
                    <p><strong>è¿½è¸ªå‹</strong> - ä¼šè¿½è¸ªç©å®¶</p>
                    <p><strong>åˆ†è£‚å‹</strong> - æ­»äº¡ååˆ†è£‚æˆä¸¤ä¸ªå°æ•Œäºº</p>
                    <p><strong>æŠ¤ç›¾å‹</strong> - æœ‰æŠ¤ç›¾ä¿æŠ¤</p>
                    <p style="color:#ff8800;"><strong>è¿·ä½ Boss</strong> - æ¯å…³ä¸­æœŸå‡ºç°</p>
                    <p style="color:#ff0000;"><strong>Boss</strong> - æ¯å…³æœ€åå‡ºç°ï¼Œå‡»è´¥åè¿›å…¥ä¸‹ä¸€å…³</p>
                </div>

                <div style="background:rgba(0,255,0,0.1); border-left:4px solid #00ff00; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#00ff00; margin-top:0;">ğŸ’¡ æ–°æ‰‹æŠ€å·§</h3>
                    <p>1. <strong>ä¿æŒç§»åŠ¨</strong> - ä¸è¦åœåœ¨åŸåœ°ï¼Œæ•Œäººä¼šåŒ…å›´ä½ </p>
                    <p>2. <strong>ä¼˜å…ˆæ‹¾å–é“å…·</strong> - æ­¦å™¨å‡çº§æ˜¯ç”Ÿå­˜çš„å…³é”®</p>
                    <p>3. <strong>åˆç†ä½¿ç”¨EMP</strong> - å±æ€¥æ—¶åˆ»ä½¿ç”¨EMPæ¸…å±</p>
                    <p>4. <strong>æ³¨æ„è¿å‡»</strong> - è¿å‡»è¶Šé«˜åˆ†æ•°å€ç‡è¶Šé«˜</p>
                    <p>5. <strong>æŠ¤ç›¾ç®¡ç†</strong> - æŠ¤ç›¾æ¶ˆè€—èƒ½é‡ï¼Œæ³¨æ„èƒ½é‡æ¡</p>
                    <p>6. <strong>Bossæˆ˜å‡†å¤‡</strong> - Bosså‡ºç°å‰å°½é‡ä¿æŒæ»¡è¡€å’Œå¼ºåŠ›æ­¦å™¨</p>
                </div>

                <div style="background:rgba(255,255,0,0.1); border-left:4px solid #ffff00; padding:15px; margin-bottom:20px; border-radius:5px;">
                    <h3 style="color:#ffff00; margin-top:0;">ğŸ† æˆå°±ä¸æ’è¡Œæ¦œ</h3>
                    <p>æ¸¸æˆä¸­æœ‰ä¸°å¯Œçš„æˆå°±ç³»ç»Ÿç­‰å¾…è§£é”ï¼</p>
                    <p>æ¯æ¬¡æ¸¸æˆéƒ½ä¼šè®°å½•åˆ†æ•°ã€æ—¶é•¿å’Œéš¾åº¦</p>
                    <p>æŒ‘æˆ˜æ’è¡Œæ¦œï¼Œæˆä¸ºæ˜Ÿé™…æœ€å¼ºé£è¡Œå‘˜ï¼</p>
                </div>

            </div>
            <div style="display:flex; gap:20px; justify-content:center; margin-top:20px;">
                <button id="guide-back-btn">è¿”å›</button>
                <button id="guide-start-btn" style="background:#00ff00; color:black;">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>

        <div id="tutorial-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:#00ffff; color:#00ffff; text-shadow: 0 0 30px #00ffff;">ğŸ‘‹ æ¬¢è¿ï¼Œæ–°é£è¡Œå‘˜ï¼</h1>
            <div style="width:80%; max-width:700px; text-align:center; font-size:18px; line-height:2;">
                <p>æ£€æµ‹åˆ°ä½ æ˜¯ç¬¬ä¸€æ¬¡è¿›å…¥éœ“è™¹æ˜Ÿæˆ˜ï¼</p>
                <p>å»ºè®®å…ˆé˜…è¯»<strong style="color:#00ff00;">å…¥å‘æŒ‡å—</strong>äº†è§£æ¸¸æˆæœºåˆ¶</p>
                <p>å‡†å¤‡å¥½æ‹¯æ•‘é“¶æ²³ç³»äº†å—ï¼Ÿ</p>
            </div>
            <div style="display:flex; gap:20px; justify-content:center; margin-top:40px;">
                <button id="tutorial-guide-btn" style="background:transparent; border:2px solid #00ff00; color:#00ff00;">æŸ¥çœ‹å…¥å‘æŒ‡å—</button>
                <button id="tutorial-start-btn" style="background:#00ffff; color:black;">ç›´æ¥å¼€å§‹</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- æ ¸å¿ƒå˜é‡ ---
        let width, height;
        let gameActive = false;
        let score = 0, level = 1, frameCount = 0;
        let combo = 0, comboTimer = 0, scoreMultiplier = 1;
        let entities = { player: null, bullets: [], enemies: [], particles: [], powerups: [], boss: null, miniBoss: null, texts: [], stars: [], obstacles: [] };
        let achievements = [];
        let unlockedAchievements = [];
        const mouse = { x: 0, y: 0 };
        
        // æ¸¸æˆæ—¶é•¿ç»Ÿè®¡
        let gameStartTime = 0;
        let gameDuration = 0;
        
        // æ’è¡Œæ¦œç³»ç»Ÿ
        const LEADERBOARD_KEY = 'spaceShooterLeaderboard';
        const MAX_LEADERBOARD_ENTRIES = 20;
        const MIN_ENTRIES_PER_DIFFICULTY = 3;
        let leaderboard = [];
        
        // é…ç½®å‚æ•°
        const CONFIG = {
            bossKillsNeeded: 30, // å¤šå°‘å‡»æ€å‡ºBoss
            bgColors: [
                {r:0, g:10, b:20},   // Lv1 æ·±ç©º
                {r:20, g:0, b:20},   // Lv2 å°è¡Œæ˜Ÿå¸¦
                {r:20, g:5, b:5},    // Lv3 æ•Œæ–¹åŸºåœ°
                {r:0, g:20, b:10},   // Lv4 è™«æ´
                {r:30, g:20, b:0},   // Lv5 ç†”å²©æ˜Ÿçƒ
                {r:40, g:0, b:40}    // Lv6 æ˜Ÿäº‘
            ],
            levelThemes: [
                'DEEP SPACE',       // Lv1
                'ASTEROID BELT',    // Lv2
                'ENEMY BASE',       // Lv3
                'WORMHOLE',         // Lv4
                'LAVA PLANET',      // Lv5
                'NEBULA'            // Lv6
            ]
        };

        // æˆå°±åˆ—è¡¨
        const ACHIEVEMENTS = [
            {
                id: 'first_kill',
                name: 'åˆéœ²é”‹èŠ’',
                description: 'é¦–æ¬¡å‡»æ€æ•Œäºº',
                condition: (stats) => stats.enemiesKilled >= 1,
                unlocked: false
            },
            {
                id: 'combo_master',
                name: 'è¿å‡»å¤§å¸ˆ',
                description: 'è¾¾æˆ20è¿å‡»',
                condition: (stats) => stats.maxCombo >= 20,
                unlocked: false
            },
            {
                id: 'combo_god',
                name: 'è¿å‡»ä¹‹ç¥',
                description: 'è¾¾æˆ50è¿å‡»',
                condition: (stats) => stats.maxCombo >= 50,
                unlocked: false
            },
            {
                id: 'boss_slayer',
                name: 'Bossæ€æ‰‹',
                description: 'é¦–æ¬¡å‡»è´¥Boss',
                condition: (stats) => stats.bossesKilled >= 1,
                unlocked: false
            },
            {
                id: 'boss_hunter',
                name: 'BossçŒäºº',
                description: 'å‡»è´¥5ä¸ªBoss',
                condition: (stats) => stats.bossesKilled >= 5,
                unlocked: false
            },
            {
                id: 'mini_boss_defeater',
                name: 'è¿·ä½ Bosså¾æœè€…',
                description: 'å‡»è´¥è¿·ä½ Boss',
                condition: (stats) => stats.miniBossesKilled >= 1,
                unlocked: false
            },
            {
                id: 'weapon_master',
                name: 'æ­¦å™¨å¤§å¸ˆ',
                description: 'å‡çº§æ‰€æœ‰æ­¦å™¨åˆ°æœ€é«˜ç­‰çº§',
                condition: (stats) => stats.weaponsUpgraded >= 5,
                unlocked: false
            },
            {
                id: 'weapon_collector',
                name: 'æ­¦å™¨æ”¶è—å®¶',
                description: 'å‡çº§æ­¦å™¨10æ¬¡',
                condition: (stats) => stats.weaponsUpgraded >= 10,
                unlocked: false
            },
            {
                id: 'score_hero',
                name: 'å¾—åˆ†è‹±é›„',
                description: 'è·å¾—10000åˆ†',
                condition: (stats) => stats.highScore >= 10000,
                unlocked: false
            },
            {
                id: 'score_legend',
                name: 'å¾—åˆ†ä¼ å¥‡',
                description: 'è·å¾—50000åˆ†',
                condition: (stats) => stats.highScore >= 50000,
                unlocked: false
            },
            {
                id: 'level_master',
                name: 'å…³å¡å¤§å¸ˆ',
                description: 'åˆ°è¾¾ç¬¬5å…³',
                condition: (stats) => stats.maxLevel >= 5,
                unlocked: false
            },
            {
                id: 'level_god',
                name: 'å…³å¡ä¹‹ç¥',
                description: 'åˆ°è¾¾ç¬¬10å…³',
                condition: (stats) => stats.maxLevel >= 10,
                unlocked: false
            },
            {
                id: 'survivor',
                name: 'ç”Ÿå­˜è€…',
                description: 'å­˜æ´»è¶…è¿‡5åˆ†é’Ÿ',
                condition: (stats) => stats.survivalTime >= 300,
                unlocked: false
            },
            {
                id: 'survivor_master',
                name: 'ç”Ÿå­˜å¤§å¸ˆ',
                description: 'å­˜æ´»è¶…è¿‡10åˆ†é’Ÿ',
                condition: (stats) => stats.survivalTime >= 600,
                unlocked: false
            },
            {
                id: 'emp_master',
                name: 'EMPå¤§å¸ˆ',
                description: 'è¿ç»­ä½¿ç”¨EMP 3æ¬¡',
                condition: (stats) => stats.empConsecutiveUses >= 3,
                unlocked: false
            },
            {
                id: 'emp_god',
                name: 'EMPä¹‹ç¥',
                description: 'è¿ç»­ä½¿ç”¨EMP 5æ¬¡',
                condition: (stats) => stats.empConsecutiveUses >= 5,
                unlocked: false
            },
            {
                id: 'shield_master',
                name: 'æŠ¤ç›¾å¤§å¸ˆ',
                description: 'ä½¿ç”¨æŠ¤ç›¾æŠµæŒ¡50æ¬¡æ”»å‡»',
                condition: (stats) => stats.shieldBlocks >= 50,
                unlocked: false
            },
            {
                id: 'kill_machine',
                name: 'æ€æˆ®æœºå™¨',
                description: 'ç´¯è®¡å‡»æ€100ä¸ªæ•Œäºº',
                condition: (stats) => stats.enemiesKilled >= 100,
                unlocked: false
            },
            {
                id: 'kill_god',
                name: 'æ€æˆ®ä¹‹ç¥',
                description: 'ç´¯è®¡å‡»æ€500ä¸ªæ•Œäºº',
                condition: (stats) => stats.enemiesKilled >= 500,
                unlocked: false
            },
            {
                id: 'perfect_game',
                name: 'å®Œç¾æ¸¸æˆ',
                description: 'æ— ä¼¤é€šå…³ç¬¬1å…³',
                condition: (stats) => stats.perfectLevel1,
                unlocked: false
            },
            {
                id: 'collector',
                name: 'æ”¶é›†è€…',
                description: 'å•å±€æ”¶é›†20ä¸ªé“å…·',
                condition: (stats) => stats.itemsCollected >= 20,
                unlocked: false
            },
            {
                id: 'collector_master',
                name: 'æ”¶é›†å¤§å¸ˆ',
                description: 'å•å±€æ”¶é›†50ä¸ªé“å…·',
                condition: (stats) => stats.itemsCollected >= 50,
                unlocked: false
            }
        ];
        let levelProgress = 0;
        let shake = 0;
        let gameStats = {
            enemiesKilled: 0,
            maxCombo: 0,
            bossesKilled: 0,
            miniBossesKilled: 0,
            weaponsUpgraded: 0,
            highScore: 0,
            maxLevel: 0,
            survivalTime: 0,
            startTime: 0,
            empConsecutiveUses: 0,
            shieldBlocks: 0,
            perfectLevel1: false,
            itemsCollected: 0,
            level1StartHp: 0
        };

        // éš¾åº¦è®¾ç½®
        let currentDifficulty = 'normal';
        const DIFFICULTY_SETTINGS = {
            easy: {
                enemySpawnRate: 1.2, // é™ä½æ•Œäººç”Ÿæˆç‡
                enemyDamage: 0.7,    // é™ä½æ•Œäººä¼¤å®³
                bossHpMultiplier: 0.8, // é™ä½Bossè¡€é‡
                playerHp: 150,       // å¢åŠ ç©å®¶è¡€é‡
                energyRegen: 0.1,    // ææ…¢èƒ½é‡å›å¤
                dropRateMultiplier: 1.5 // æé«˜æ‰è½ç‡
            },
            normal: {
                enemySpawnRate: 1.0,
                enemyDamage: 1.0,
                bossHpMultiplier: 1.0,
                playerHp: 100,
                energyRegen: 0.05,   // å¾ˆæ…¢èƒ½é‡å›å¤
                dropRateMultiplier: 1.0 // æ ‡å‡†æ‰è½ç‡
            },
            hard: {
                enemySpawnRate: 0.8,  // å¢åŠ æ•Œäººç”Ÿæˆç‡
                enemyDamage: 1.3,     // å¢åŠ æ•Œäººä¼¤å®³
                bossHpMultiplier: 1.2, // å¢åŠ Bossè¡€é‡
                playerHp: 80,        // å‡å°‘ç©å®¶è¡€é‡
                energyRegen: 0.02,   // ææ…¢èƒ½é‡å›å¤
                dropRateMultiplier: 0.8 // é™ä½æ‰è½ç‡
            }
        };

        // --- åˆå§‹åŒ–ä¸äº‹ä»¶ ---
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        window.onresize = resize; resize();
        window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
        window.ontouchmove = e => { e.preventDefault(); mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; };

        // é”®ç›˜çŠ¶æ€
        const keys = {};
        const weaponKeys = {
            '1': 'spread',
            '2': 'missile',
            '3': 'laser',
            '4': 'flamethrower',
            '5': 'emp',
            '6': 'time',
            '7': 'split',
            '8': 'shield',
            '9': 'superlaser'
        };
        // æ­¦å™¨åˆ‡æ¢æŒ‰é”®çŠ¶æ€è·Ÿè¸ª
        const weaponKeyPressed = {};
        
        window.onkeydown = e => {
            keys[e.key.toLowerCase()] = true;
            // æ­¦å™¨åˆ‡æ¢ - é˜²æ­¢é•¿æŒ‰é‡å¤è§¦å‘
            const weaponType = weaponKeys[e.key];
            if (weaponType && entities.player && !weaponKeyPressed[e.key]) {
                weaponKeyPressed[e.key] = true;
                const p = entities.player;
                // ä¿å­˜å½“å‰æ­¦å™¨ç­‰çº§
                p.weaponLevels[p.weapon] = p.weaponLevel;
                // åˆ‡æ¢æ­¦å™¨
                p.weapon = weaponType;
                // æ¢å¤æ–°æ­¦å™¨çš„ç­‰çº§
                p.weaponLevel = p.weaponLevels[weaponType];
                createFloatText(p.x, p.y - 30, `${p.weapons[weaponType].name} LV.${p.weaponLevel}`, p.weapons[weaponType].color);
                updateHUD();
            }
        };
        // EMPæŒ‰é”®çŠ¶æ€
        let empKeyPressed = false;
        
        window.onkeydown = e => {
            keys[e.key.toLowerCase()] = true;
            
            // EMPæŠ€èƒ½ - æŒ‰Eé”®ä½¿ç”¨
            if (e.key.toLowerCase() === 'e' && entities.player && !empKeyPressed) {
                empKeyPressed = true;
                entities.player.activateEMP();
            }
            
            // æ­¦å™¨åˆ‡æ¢ - é˜²æ­¢é•¿æŒ‰é‡å¤è§¦å‘
            const weaponType = weaponKeys[e.key];
            if (weaponType && entities.player && !weaponKeyPressed[e.key]) {
                weaponKeyPressed[e.key] = true;
                const p = entities.player;
                // ä¿å­˜å½“å‰æ­¦å™¨ç­‰çº§
                p.weaponLevels[p.weapon] = p.weaponLevel;
                // åˆ‡æ¢æ­¦å™¨
                p.weapon = weaponType;
                // æ¢å¤æ–°æ­¦å™¨çš„ç­‰çº§
                p.weaponLevel = p.weaponLevels[weaponType];
                createFloatText(p.x, p.y - 30, `${p.weapons[weaponType].name} LV.${p.weaponLevel}`, p.weapons[weaponType].color);
                updateHUD();
            }
        };
        
        window.onkeyup = e => { 
            keys[e.key.toLowerCase()] = false; 
            // é‡ç½®æ­¦å™¨æŒ‰é”®çŠ¶æ€
            if (weaponKeys[e.key]) {
                weaponKeyPressed[e.key] = false;
            }
            // é‡ç½®EMPæŒ‰é”®çŠ¶æ€
            if (e.key.toLowerCase() === 'e') {
                empKeyPressed = false;
            }
        };

        // éš¾åº¦é€‰æ‹©æŒ‰é’®äº‹ä»¶
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.difficulty-btn').forEach(b => {
                    b.style.background = 'transparent';
                    b.style.color = '#00ffff';
                });
                // è®¾ç½®å½“å‰æŒ‰é’®ä¸ºé€‰ä¸­çŠ¶æ€
                this.style.background = '#00ffff';
                this.style.color = 'black';
                // æ›´æ–°å½“å‰éš¾åº¦
                currentDifficulty = this.dataset.difficulty;
            });
        });

        // --- å®ä½“ç±»å®šä¹‰ ---

        class Player {
            constructor() {
                this.x = width/2; this.y = height - 100;
                this.radius = 18;
                const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
                this.hp = diffSettings.playerHp; this.maxHp = diffSettings.playerHp;
                this.color = '#00ffff';
                
                // æ­¦å™¨ç³»ç»Ÿ
                this.weapon = 'spread'; // spread, missile, laser, flamethrower, emp, time, split, shield
                this.weaponLevel = 1;
                this.lastShot = 0;
                this.energy = 100;
                this.maxEnergy = 100;
                this.energyRegen = diffSettings.energyRegen;
                this.subWeapon = null;
                this.subWeaponLevel = 1;
                this.shieldActive = false;
                this.shieldCooldown = 0;
                this.timeSlowActive = false;
                this.timeSlowCooldown = 0;
                this.damageBoost = false;
                this.damageBoostTimer = 0;
                
                // å…è´¹ä½¿ç”¨è®¡æ—¶å™¨
                this.freeUseTimer = 0;
                this.freeUseWeapon = null;
                
                // EMPæŠ€èƒ½ç³»ç»Ÿ
                this.empCharges = 0; // EMPä½¿ç”¨æ¬¡æ•°
                this.empActive = false; // EMPæ˜¯å¦æ¿€æ´»
                this.empDuration = 300; // EMPæŒç»­æ—¶é—´ï¼ˆ5ç§’ï¼‰
                this.empTimer = 0; // EMPå‰©ä½™æ—¶é—´
                
                // æ­¦å™¨é…ç½®
                this.weapons = {
                    'spread': { delay: 10, color: '#00ffff', name: 'PULSE SPREAD', energy: 0 },
                    'missile': { delay: 25, color: '#ff00ff', name: 'HOMING MISSILE', energy: 5 },
                    'laser': { delay: 6, color: '#4488ff', name: 'HYPER BEAM', energy: 0 },
                    'flamethrower': { delay: 2, color: '#ff8800', name: 'FLAME THROWER', energy: 2 },
                    'time': { delay: 1, color: '#00ff88', name: 'TIME SLOW', energy: 5 },
                    'split': { delay: 15, color: '#ffff00', name: 'SPLIT SHOT', energy: 8 },
                    'shield': { delay: 120, color: '#4488ff', name: 'SHIELD', energy: 50 },
                    'superlaser': { delay: 120, color: '#ff0000', name: 'SUPER LASER', energy: 100 }
                };
                
                // EMPæŠ€èƒ½é…ç½®
                this.empConfig = { color: '#8844ff', name: 'EMP BLAST' };
                
                // æ­¦å™¨ç­‰çº§è®°å½• (ç”¨äºåˆ‡æ¢æ—¶ä¿ç•™ç­‰çº§)
                this.weaponLevels = {
                    'spread': 1,
                    'missile': 1,
                    'laser': 1,
                    'flamethrower': 1,
                    'time': 1,
                    'split': 1,
                    'shield': 1,
                    'superlaser': 1
                };
            }

            update() {
                // ç§»åŠ¨ - è·Ÿéšé¼ æ ‡
                this.x += (mouse.x - this.x) * 0.15;
                this.y += (mouse.y - this.y) * 0.15;
                this.x = Math.max(this.radius, Math.min(width-this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(height-this.radius, this.y));

                // å›ºå®šå‘ä¸Šå°„å‡»
                this.aimAngle = -Math.PI / 2;

                // èƒ½é‡å›å¤
                this.energy = Math.min(this.maxEnergy, this.energy + this.energyRegen);

                // å†·å´æ—¶é—´
                if (this.shieldCooldown > 0) this.shieldCooldown--;
                if (this.timeSlowCooldown > 0) this.timeSlowCooldown--;

                // æŠ¤ç›¾æŒç»­æ—¶é—´
                if (this.shieldActive && this.energy < 10) {
                    this.shieldActive = false;
                }

                // æ—¶é—´å‡é€ŸæŒç»­æ—¶é—´
                if (this.timeSlowActive && this.energy < 20) {
                    this.timeSlowActive = false;
                }

                // ä¼¤å®³å¼ºåŒ–è®¡æ—¶å™¨
                if (this.damageBoostTimer > 0) {
                    this.damageBoostTimer--;
                    if (this.damageBoostTimer <= 0) {
                        this.damageBoost = false;
                        createFloatText(this.x, this.y - 30, "DAMAGE BOOST ENDED", "#ff6600");
                    }
                }

                // å…è´¹ä½¿ç”¨è®¡æ—¶å™¨
                if (this.freeUseTimer > 0) {
                    this.freeUseTimer--;
                    if (this.freeUseTimer <= 0 && this.freeUseWeapon) {
                        createFloatText(this.x, this.y - 50, `${this.weapons[this.freeUseWeapon].name} FREE TIME ENDED!`, "#ffff00");
                        this.freeUseWeapon = null;
                    }
                }

                // EMPè®¡æ—¶å™¨
                if (this.empTimer > 0) {
                    this.empTimer--;
                    if (this.empTimer <= 0) {
                        this.empActive = false;
                        // EMPç»“æŸæ—¶å…³é—­æŠ¤ç›¾
                        this.shieldActive = false;
                        createFloatText(this.x, this.y - 50, "EMP ENDED!", "#8844ff");
                    }
                }

                // å°„å‡» (è‡ªåŠ¨å‘é¼ æ ‡æ–¹å‘å°„å‡»)
                const wConfig = this.weapons[this.weapon];
                const isFreeUse = this.freeUseTimer > 0 && this.freeUseWeapon === this.weapon;
                if (frameCount - this.lastShot > wConfig.delay) {
                    if (isFreeUse || this.energy >= wConfig.energy) {
                        this.fire(this.weapon, this.aimAngle);
                        this.lastShot = frameCount;
                        if (!isFreeUse) {
                            this.energy -= wConfig.energy;
                        }
                    }
                }
            }

            fire(type, aimAngle) {
                const bulletSpeed = 18;
                const bx = this.x + Math.cos(aimAngle) * 25;
                const by = this.y + Math.sin(aimAngle) * 25;
                
                // ä¼¤å®³å¼ºåŒ–å€ç‡
                const damageMultiplier = this.damageBoost ? 2 : 1;
                
                if (type === 'spread') {
                    // ä¸»å¼¹
                    const damage = 1 * this.weaponLevel * damageMultiplier;
                    entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle) * bulletSpeed, Math.sin(aimAngle) * bulletSpeed, type, damage));
                    if (this.weaponLevel >= 2) {
                        // ä¸¤ä¾§å¼¹
                        entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle - 0.15) * bulletSpeed, Math.sin(aimAngle - 0.15) * bulletSpeed, type, damage));
                        entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle + 0.15) * bulletSpeed, Math.sin(aimAngle + 0.15) * bulletSpeed, type, damage));
                    }
                    if (this.weaponLevel >= 3) {
                        // æ›´å¤šä¾§å¼¹
                        entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle - 0.3) * bulletSpeed, Math.sin(aimAngle - 0.3) * bulletSpeed, type, damage));
                        entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle + 0.3) * bulletSpeed, Math.sin(aimAngle + 0.3) * bulletSpeed, type, damage));
                    }
                } else if (type === 'missile') {
                    // å¯¼å¼¹ - å‘é¼ æ ‡æ–¹å‘å‘å°„ï¼Œä½†æœ‰åˆ¶å¯¼
                    let count = this.weaponLevel * 2;
                    const damage = 3 * damageMultiplier;
                    for(let i=0; i<count; i++) {
                        const spread = (Math.random() - 0.5) * 0.3;
                        const angle = aimAngle + spread;
                        entities.bullets.push(new Bullet(bx, by, Math.cos(angle) * 8, Math.sin(angle) * 8, type, damage));
                    }
                } else if (type === 'laser') {
                    // æ¿€å…‰ - é«˜é€Ÿç›´çº¿
                    const damage = 3 * this.weaponLevel * damageMultiplier;
                    entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle) * 30, Math.sin(aimAngle) * 30, type, damage));
                    if (this.weaponLevel >= 2) {
                        const perpAngle = aimAngle + Math.PI/2;
                        entities.bullets.push(new Bullet(bx + Math.cos(perpAngle) * 10, by + Math.sin(perpAngle) * 10, Math.cos(aimAngle) * 30, Math.sin(aimAngle) * 30, type, damage));
                        entities.bullets.push(new Bullet(bx - Math.cos(perpAngle) * 10, by - Math.sin(perpAngle) * 10, Math.cos(aimAngle) * 30, Math.sin(aimAngle) * 30, type, damage));
                    }
                } else if (type === 'flamethrower') {
                    // ç«ç„°å–·å°„å™¨ - æ‰‡å½¢æ‰©æ•£
                    const damage = 2 * this.weaponLevel * damageMultiplier;
                    for(let i=0; i<3; i++) {
                        const spread = (i - 1) * 0.2;
                        const angle = aimAngle + spread;
                        entities.bullets.push(new Bullet(bx, by, Math.cos(angle) * 15, Math.sin(angle) * 15, type, damage));
                    }
                } else if (type === 'emp') {
                    // ç”µç£è„‰å†² - ç‚¹å‡»æŒ‰é’®å¼•çˆ†ä¸€æ¬¡
                    this.fireEMP();
                } else if (type === 'time') {
                    // æ—¶é—´å‡é€Ÿ
                    this.timeSlowActive = true;
                    this.timeSlowCooldown = 120;
                } else if (type === 'split') {
                    // åˆ†è£‚å¼¹
                    const damage = 4 * this.weaponLevel * damageMultiplier;
                    entities.bullets.push(new Bullet(bx, by, Math.cos(aimAngle) * 20, Math.sin(aimAngle) * 20, type, damage));
                } else if (type === 'shield') {
                    // æŠ¤ç›¾ - æŒ‰8åˆ‡æ¢å¼€å¯/å…³é—­
                    if (this.shieldActive) {
                        // å…³é—­æŠ¤ç›¾
                        this.shieldActive = false;
                        createFloatText(this.x, this.y - 30, "SHIELD OFF", "#4488ff");
                    } else if (this.shieldCooldown <= 0) {
                        // å¼€å¯æŠ¤ç›¾
                        this.shieldActive = true;
                        this.shieldCooldown = 300;
                    }
                } else if (type === 'superlaser') {
                    // è¶…èƒ½æ¿€å…‰ - ç§’æ€ä¸€åˆ‡éBosså•ä½
                    this.fireSuperLaser(aimAngle);
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // å°¾ç„°
                ctx.fillStyle = `rgba(0, 255, 255, ${Math.random()})`;
                ctx.beginPath(); ctx.moveTo(-8, 15); ctx.lineTo(0, 35 + Math.random()*20); ctx.lineTo(8, 15); ctx.fill();

                // æœºä½“
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -25); ctx.lineTo(20, 20); ctx.lineTo(0, 10); ctx.lineTo(-20, 20);
                ctx.fill();

                // æŠ¤ç›¾æ•ˆæœ
                if (this.shieldActive) {
                    ctx.strokeStyle = `rgba(68, 136, 255, ${0.5 + Math.sin(frameCount * 0.1) * 0.3})`;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 30; ctx.shadowColor = '#4488ff';
                    ctx.beginPath(); ctx.arc(0,0,this.radius+15,0,Math.PI*2); ctx.stroke();
                }
                
                // æ—¶é—´å‡é€Ÿæ•ˆæœ
                if (this.timeSlowActive) {
                    ctx.strokeStyle = `rgba(0, 255, 136, ${0.3 + Math.sin(frameCount * 0.1) * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20; ctx.shadowColor = '#00ff88';
                    ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.stroke();
                }

                // æ™®é€šæŠ¤ç›¾åœˆ
                if (frameCount % 60 < 30) {
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0,this.radius+5,0,Math.PI*2); ctx.stroke();
                }
                ctx.restore();
            }

            activateEMP() {
                // æ£€æŸ¥æ˜¯å¦æœ‰ä½¿ç”¨æ¬¡æ•°
                if (this.empCharges <= 0) {
                    createFloatText(this.x, this.y - 30, "NO EMP CHARGES!", "#ff0000");
                    // é‡ç½®è¿ç»­ä½¿ç”¨è®¡æ•°
                    gameStats.empConsecutiveUses = 0;
                    return;
                }
                
                // æ¶ˆè€—ä½¿ç”¨æ¬¡æ•°
                this.empCharges--;
                
                // å¢åŠ è¿ç»­ä½¿ç”¨è®¡æ•°
                gameStats.empConsecutiveUses++;
                
                // æ¿€æ´»EMP
                this.empActive = true;
                this.empTimer = this.empDuration;
                
                // è‡ªåŠ¨å¼€å¯å…è´¹æŠ¤ç›¾
                this.shieldActive = true;
                this.shieldCooldown = 0; // é‡ç½®æŠ¤ç›¾å†·å´
                
                createFloatText(this.x, this.y - 50, `EMP ACTIVATED! (${this.empCharges} left)`, "#8844ff");
                
                // æ‰§è¡ŒEMPçˆ†ç‚¸æ•ˆæœ
                this.fireEMPBlast();
            }
            
            fireEMPBlast() {
                // ç‚«é…·çš„ç”µç£è„‰å†²çˆ†ç‚¸ç‰¹æ•ˆ
                const range = 250;
                const damage = 50 * (this.damageBoost ? 2 : 1);
                
                // èŒƒå›´æŒ‡ç¤ºåœˆ - æå‰æ˜¾ç¤º
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        entities.particles.push(new RangeIndicator(this.x, this.y, range, i));
                    }, i * 100);
                }
                
                // å»¶è¿Ÿåäº§ç”Ÿå®é™…ä¼¤å®³
                setTimeout(() => {
                    // å¤šå±‚çˆ†ç‚¸ç‰¹æ•ˆ
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            createExplosion(this.x, this.y, i % 2 === 0 ? '#8844ff' : '#ff00ff', 15 + i * 5);
                        }, i * 100);
                    }
                    
                    // å†²å‡»æ³¢æ•ˆæœ - åˆ›å»ºè§†è§‰åœ†åœˆ
                    for (let r = 20; r <= range; r += 30) {
                        setTimeout(() => {
                            entities.particles.push(new Shockwave(this.x, this.y, r));
                        }, (r / 30) * 50);
                    }
                    
                    // æ¸…é™¤æ•Œäººå­å¼¹
                    entities.bullets = entities.bullets.filter(b => 
                        !(b.type.startsWith('enemy') && Math.hypot(b.x - this.x, b.y - this.y) < range)
                    );
                    
                    // å¯¹æ•Œäººé€ æˆä¼¤å®³
                    entities.enemies.forEach(e => {
                        if (e.active && Math.hypot(e.x - this.x, e.y - this.y) < range) {
                            e.hp -= damage;
                            if (e.hp <= 0) killEnemy(e);
                        }
                    });
                    
                    // å¯¹éšœç¢ç‰©é€ æˆä¼¤å®³
                    entities.obstacles.forEach(obs => {
                        if (obs.active && obs.type === 'meteor' && Math.hypot(obs.x - this.x, obs.y - this.y) < range) {
                            obs.hp -= damage;
                            if (obs.hp <= 0) {
                                obs.active = false;
                                createMeteorFragments(obs.x, obs.y);
                                score += 50;
                            }
                        }
                    });
                    
                    // å¯¹Bossé€ æˆä¼¤å®³
                    if (entities.boss && entities.boss.active) {
                        if (Math.hypot(entities.boss.x - this.x, entities.boss.y - this.y) < range) {
                            entities.boss.hp -= damage * 2;
                        }
                    }
                    
                    // å±å¹•éœ‡åŠ¨
                    shake = 20;
                    
                    createFloatText(this.x, this.y - 80, "EMP BLAST!", "#8844ff");
                }, 300); // å»¶è¿Ÿ300msåçˆ†ç‚¸
            }

            fireSuperLaser(aimAngle) {
                // è¶…èƒ½æ¿€å…‰ - ç§’æ€ä¸€åˆ‡éBosså•ä½
                const laserWidth = 40;
                const laserLength = height;
                
                // ç‚«é…·çš„æ¿€å…‰ç‰¹æ•ˆ
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        createExplosion(this.x + (Math.random() - 0.5) * laserWidth, this.y - i * (laserLength / 10), '#ff0000', 10);
                    }, i * 30);
                }
                
                // æ¿€å…‰è·¯å¾„ä¸Šçš„æ‰€æœ‰æ•Œäººã€éšœç¢ç‰©éƒ½è¢«ç§’æ€
                const bx = this.x;
                const by = this.y;
                
                // ç§’æ€æ•Œäºº
                entities.enemies.forEach(e => {
                    if (e.active) {
                        const dist = Math.abs(e.x - bx);
                        if (dist < laserWidth / 2 + e.radius && e.y < by) {
                            e.hp = 0;
                            killEnemy(e);
                        }
                    }
                });
                
                // ç§’æ€éšœç¢ç‰©ï¼ˆå°è¡Œæ˜Ÿï¼‰
                entities.obstacles.forEach(obs => {
                    if (obs.active && obs.type === 'meteor') {
                        const dist = Math.abs(obs.x - bx);
                        if (dist < laserWidth / 2 + obs.radius && obs.y < by) {
                            obs.active = false;
                            createMeteorFragments(obs.x, obs.y);
                            score += 50;
                        }
                    }
                });
                
                // ç§’æ€è¿·ä½ Boss
                if (entities.miniBoss && entities.miniBoss.active) {
                    const dist = Math.abs(entities.miniBoss.x - bx);
                    if (dist < laserWidth / 2 + entities.miniBoss.radius && entities.miniBoss.y < by) {
                        entities.miniBoss.hp = 0;
                        entities.miniBoss.active = false;
                        createExplosion(entities.miniBoss.x, entities.miniBoss.y, '#ff8800', 15);
                        score += 1000 * level;
                        gameStats.miniBossesKilled++;
                        createFloatText(entities.miniBoss.x, entities.miniBoss.y, "MINI BOSS DEFEATED!", "#ff8800");
                        entities.miniBoss = null;
                    }
                }
                
                // å¯¹Bossé€ æˆä¼¤å®³ï¼ˆä¸ç§’æ€ï¼‰
                if (entities.boss && entities.boss.active) {
                    const dist = Math.abs(entities.boss.x - bx);
                    if (dist < laserWidth / 2 + entities.boss.radius && entities.boss.y < by) {
                        entities.boss.hp -= 100;
                        createFloatText(entities.boss.x, entities.boss.y - 50, "-100", "#ff0000");
                    }
                }
                
                // å±å¹•éœ‡åŠ¨
                shake = 30;
                
                createFloatText(this.x, this.y - 50, "SUPER LASER!", "#ff0000");
            }
        }

        // èŒƒå›´æŒ‡ç¤ºåœˆç±» - ç”¨äºEMPèŒƒå›´æç¤º
        class RangeIndicator {
            constructor(x, y, radius, index) {
                this.x = x; this.y = y;
                this.radius = radius;
                this.index = index;
                this.life = 1;
                this.decay = 0.03;
                this.active = true;
            }
            
            update() {
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.strokeStyle = `rgba(136, 68, 255, ${this.life})`;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#8844ff';
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // å†…éƒ¨å¡«å……
                ctx.fillStyle = `rgba(136, 68, 255, ${this.life * 0.1})`;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // å†²å‡»æ³¢ç±» - ç”¨äºEMPç‰¹æ•ˆ
        class Shockwave {
            constructor(x, y, radius) {
                this.x = x; this.y = y;
                this.radius = radius;
                this.maxRadius = radius;
                this.life = 1;
                this.decay = 0.05;
                this.active = true;
            }
            
            update() {
                this.life -= this.decay;
                if (this.life <= 0) this.active = false;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.strokeStyle = `rgba(136, 68, 255, ${this.life})`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#8844ff';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        // ç ´ç‰‡ç±» - å°è¡Œæ˜Ÿçˆ†ç‚¸äº§ç”Ÿ
        class Fragment {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.radius = 5 + Math.random() * 5;
                this.active = true;
                this.life = 120; // 2ç§’
                this.damage = 20;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                if (this.life <= 0 || this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.active = false;
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#ff6600';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff6600';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // åˆ›å»ºå°è¡Œæ˜Ÿç ´ç‰‡
        function createMeteorFragments(x, y) {
            const fragmentCount = 8 + Math.floor(Math.random() * 4); // 8-12ä¸ªç ´ç‰‡
            for (let i = 0; i < fragmentCount; i++) {
                const angle = (Math.PI * 2 / fragmentCount) * i + Math.random() * 0.5;
                const speed = 8 + Math.random() * 4;
                entities.fragments = entities.fragments || [];
                entities.fragments.push(new Fragment(x, y, angle, speed));
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, type, dmgOverride) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.type = type; // spread, missile, laser, flamethrower, split, enemy_basic, enemy_laser
                this.active = true;
                this.target = null; // for missile
                this.damage = dmgOverride || 1;
                this.life = 60;
                
                if (type === 'missile') this.damage = 3;
                if (type === 'flamethrower') this.damage = 2;
                if (type === 'split') this.damage = 4;
                if (type.startsWith('enemy')) this.damage = 10;
            }

            update() {
                if (this.type === 'missile') {
                    // å¯¼å¼¹åˆ¶å¯¼é€»è¾‘
                    if (!this.target || !this.target.active) {
                        // å¯»æ‰¾æ–°ç›®æ ‡
                        let closest = null;
                        let minDist = 1000;
                        const targets = entities.boss ? [entities.boss] : entities.enemies;
                        
                        targets.forEach(e => {
                            if (!e.active) return;
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d < minDist) { minDist = d; closest = e; }
                        });
                        this.target = closest;
                    }

                    if (this.target) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        // æƒ¯æ€§è½¬å‘
                        this.vx += Math.cos(angle) * 1;
                        this.vy += Math.sin(angle) * 1;
                        // é€Ÿåº¦é™åˆ¶
                        const speed = Math.hypot(this.vx, this.vy);
                        if(speed > 12) { this.vx *= 0.95; this.vy *= 0.95; }
                    } else {
                        this.vy -= 0.5; // æ— ç›®æ ‡å‘ä¸ŠåŠ é€Ÿ
                    }
                } 

                this.x += this.vx;
                this.y += this.vy;

                // ç²’å­æ‹–å°¾
                if (this.type === 'missile' && frameCount % 3 === 0) {
                    entities.particles.push(new Particle(this.x, this.y, '#ff00ff', 0.5));
                }
                if (this.type === 'flamethrower' && frameCount % 2 === 0) {
                    entities.particles.push(new Particle(this.x, this.y, '#ff8800', 0.8));
                }
                if (this.type === 'split' && frameCount % 4 === 0) {
                    entities.particles.push(new Particle(this.x, this.y, '#ffff00', 0.6));
                }

                // ç«ç„°è¡°å‡
                if (this.type === 'flamethrower') {
                    this.life--;
                    if (this.life <= 0) this.active = false;
                }

                if (this.x < -50 || this.x > width + 50 || this.y < -50 || this.y > height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 10;
                
                if (this.type === 'spread') {
                    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'missile') {
                    ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
                    ctx.fillStyle = '#ff00ff'; ctx.fillRect(-3, -8, 6, 16);
                } else if (this.type === 'laser') {
                    ctx.fillStyle = '#4488ff'; ctx.shadowColor='#4488ff';
                    ctx.fillRect(-3, -20, 6, 40);
                } else if (this.type === 'flamethrower') {
                    ctx.fillStyle = '#ff8800'; ctx.shadowColor='#ff8800';
                    ctx.beginPath(); ctx.arc(0,0,8,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'split') {
                    ctx.fillStyle = '#ffff00'; ctx.shadowColor='#ffff00';
                    ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
                } else if (this.type.startsWith('enemy')) {
                    ctx.fillStyle = '#ff0000'; ctx.shadowColor='red';
                    ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Enemy {
            constructor(type) {
                this.x = Math.random() * (width - 40) + 20;
                this.y = -50;
                this.type = type; // basic, shooter, drone, tracker, splitter, shield, elite_drone
                this.active = true;
                this.hp = 3 + (level * 1.5);
                this.radius = 20;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * 2 + 2 + (level * 0.2);
                this.color = '#ff3333';
                this.maxHp = this.hp;
                this.shield = 0;
                this.speed = 2;
                
                if (type === 'shooter') {
                    this.color = '#cc00ff'; this.vy = 1.5; this.hp *= 1.5;
                }
                if (type === 'drone') {
                    this.color = '#ffaa00'; this.radius = 12; this.hp = 1; this.vy = 5;
                }
                if (type === 'tracker') {
                    this.color = '#00ffff'; this.radius = 18; this.hp *= 1.2; this.speed = 3;
                }
                if (type === 'splitter') {
                    this.color = '#ffff00'; this.radius = 22; this.hp *= 2;
                }
                if (type === 'shield') {
                    this.color = '#4488ff'; this.radius = 20; this.hp *= 1.5; this.shield = 5;
                }
                if (type === 'elite_drone') {
                    this.color = '#ff00ff'; this.radius = 15; this.hp = 5; this.vy = 3;
                }
            }

            update() {
                this.timer = (this.timer || 0) + 1;
                
                // è¿½è¸ªè€…é€»è¾‘ - ä¸»åŠ¨è¿½è¸ªç©å®¶
                if (this.type === 'tracker') {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                }
                // åŸºç¡€æ•Œäºº - æ³¢æµªå½¢ç§»åŠ¨
                else if (this.type === 'basic') {
                    this.vx = Math.sin(this.timer * 0.05) * 2;
                }
                // å°„å‡»è€… - å·¦å³ç§»åŠ¨å¹¶å°„å‡»
                else if (this.type === 'shooter') {
                    this.x += Math.sin(this.timer * 0.03) * 3;
                }
                // æ— äººæœº - å¿«é€Ÿä¸‹å†²
                else if (this.type === 'drone') {
                    // å¿«é€Ÿç›´çº¿ç§»åŠ¨
                }
                // åˆ†è£‚è€… - é”¯é½¿å½¢ç§»åŠ¨
                else if (this.type === 'splitter') {
                    if (this.timer % 60 === 0) {
                        this.vx = (Math.random() - 0.5) * 6;
                    }
                }
                // æŠ¤ç›¾å…µ - ç¼“æ…¢ä½†ç¨³å®šåœ°æ¥è¿‘ç©å®¶
                else if (this.type === 'shield') {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    this.vx += Math.cos(angle) * 0.1;
                    this.vy += Math.sin(angle) * 0.1;
                    // é™åˆ¶é€Ÿåº¦
                    const speed = Math.hypot(this.vx, this.vy);
                    if (speed > 2) {
                        this.vx *= 0.95;
                        this.vy *= 0.95;
                    }
                }
                // ç²¾è‹±æ— äººæœº - å›´ç»•ç©å®¶ç›˜æ—‹
                else if (this.type === 'elite_drone') {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    // ç›˜æ—‹ç§»åŠ¨
                    this.vx = Math.cos(angle + Math.PI/2) * 3 + Math.cos(angle) * 1;
                    this.vy = Math.sin(angle + Math.PI/2) * 3 + Math.sin(angle) * 1;
                }
                
                this.x += this.vx; 
                this.y += this.vy;
                
                // è¾¹ç•Œåå¼¹
                if (this.x < this.radius || this.x > width - this.radius) {
                    this.vx *= -1;
                    this.x = Math.max(this.radius, Math.min(width - this.radius, this.x));
                }

                // å°„å‡»é€»è¾‘
                if (this.type === 'shooter' && Math.random() < 0.015) {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'enemy_basic'));
                }
                
                if (this.type === 'elite_drone' && Math.random() < 0.03) {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, 'enemy_basic'));
                }
                
                // æŠ¤ç›¾å…µä¹Ÿä¼šå°„å‡»
                if (this.type === 'shield' && Math.random() < 0.01) {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*5, Math.sin(angle)*5, 'enemy_basic'));
                }

                if (this.y > height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                
                if (this.type === 'basic') {
                    ctx.beginPath(); ctx.moveTo(0,15); ctx.lineTo(15,-15); ctx.lineTo(-15,-15); ctx.fill();
                } else if (this.type === 'shooter') {
                    ctx.rotate(frameCount * 0.05);
                    ctx.fillRect(-12,-12,24,24);
                } else if (this.type === 'drone') {
                    ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'tracker') {
                    ctx.beginPath(); ctx.moveTo(0,-15); ctx.lineTo(12,15); ctx.lineTo(0,5); ctx.lineTo(-12,15); ctx.fill();
                } else if (this.type === 'splitter') {
                    ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'shield') {
                    ctx.beginPath(); ctx.moveTo(0,20); ctx.lineTo(15,-10); ctx.lineTo(-15,-10); ctx.fill();
                    if (this.shield > 0) {
                        ctx.strokeStyle = '#4488ff'; ctx.lineWidth = 3; ctx.shadowBlur = 20;
                        ctx.beginPath(); ctx.arc(0,0,this.radius+10,0,Math.PI*2); ctx.stroke();
                    }
                } else if (this.type === 'elite_drone') {
                    ctx.rotate(frameCount * 0.1);
                    ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(8,10); ctx.lineTo(-8,10); ctx.fill();
                }
                
                // ç®€æ˜“è¡€æ¡
                if(this.hp < this.maxHp) {
                    ctx.fillStyle = 'red'; ctx.fillRect(-15, -25, 30 * (this.hp/this.maxHp), 3);
                }
                ctx.restore();
            }
        }

        // --- Boss é€»è¾‘ ---
        class Boss {
            constructor(level) {
                this.active = true;
                this.x = width / 2; this.y = -150;
                this.radius = 70;
                const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
                this.maxHp = 300 * level * diffSettings.bossHpMultiplier;
                this.hp = this.maxHp;
                this.phase = 'enter';
                this.timer = 0;
                this.level = level;
                this.isEnraged = false;
                this.rageTimer = 0;
                
                // Boss ç±»å‹é…ç½®
                const types = ['DESTROYER', 'SPEEDSTER', 'CARRIER'];
                this.bossType = types[(level - 1) % 3];
                
                // åå­—æ˜¾ç¤º
                document.getElementById('boss-name').innerText = `âš ï¸ ${this.bossType} âš ï¸`;
                document.getElementById('boss-hud').style.display = 'flex';
            }

            update() {
                this.timer++;
                
                // æ£€æŸ¥ç‹‚æš´æ¨¡å¼
                if (!this.isEnraged && this.hp < this.maxHp * 0.5) {
                    this.isEnraged = true;
                    this.rageTimer = 0;
                    document.getElementById('boss-name').innerText = `âš ï¸ ${this.bossType} RAGE âš ï¸`;
                    createFloatText(this.x, this.y, "BOSS ENRAGED!", "#ff0000");
                }

                // å…¥åœº
                if (this.phase === 'enter') {
                    this.y += 1.5;
                    if (this.y > 150) this.phase = 'combat';
                    return;
                }

                // é€šç”¨ç§»åŠ¨
                if (this.bossType === 'SPEEDSTER') {
                    // å¿«é€Ÿå·¦å³å†²åˆº
                    const speed = this.isEnraged ? 0.08 : 0.05;
                    this.x = width/2 + Math.sin(this.timer * speed) * (width/2 - 50);
                } else {
                    // ç¼“æ…¢ç§»åŠ¨
                    const speed = this.isEnraged ? 0.04 : 0.02;
                    this.x = width/2 + Math.sin(this.timer * speed) * (width/3);
                }

                // æŠ€èƒ½é‡Šæ”¾é¢‘ç‡
                const skillInterval = this.isEnraged ? 0.5 : 1;

                // æŠ€èƒ½é‡Šæ”¾
                if (this.bossType === 'DESTROYER') {
                    // å¼¹å¹•åœ°ç‹±
                    if (this.timer % Math.floor(10 * skillInterval) === 0) { // èºæ—‹å¼¹
                        const angle = this.timer * 0.1;
                        for(let i=0; i<4; i++) {
                            const a = angle + (Math.PI/2)*i;
                            entities.bullets.push(new Bullet(this.x, this.y, Math.cos(a)*4, Math.sin(a)*4, 'enemy_basic'));
                        }
                    }
                    // ç‹‚æš´æ¨¡å¼ï¼šç¯å½¢å¼¹å¹•
                    if (this.isEnraged && this.timer % Math.floor(60 * skillInterval) === 0) {
                        for(let i=0; i<8; i++) {
                            const angle = (Math.PI*2/8)*i;
                            entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'enemy_basic'));
                        }
                    }
                } 
                else if (this.bossType === 'SPEEDSTER') {
                    // æ¿€å…‰è¿å°„
                    if (this.timer % Math.floor(90 * skillInterval) === 0) {
                        for(let i=-2; i<=2; i++) {
                             entities.bullets.push(new Bullet(this.x, this.y + 40, i*2, 8, 'enemy_laser'));
                        }
                    }
                    // ç‹‚æš´æ¨¡å¼ï¼šå¿«é€Ÿå†²åˆº
                    if (this.isEnraged && this.timer % Math.floor(30 * skillInterval) === 0) {
                        const targetX = Math.random() * width;
                        const angle = Math.atan2(targetX - this.x, 0);
                        this.vx = Math.cos(angle) * 20;
                        setTimeout(() => {
                            this.vx = 0;
                        }, 1000);
                    }
                }
                else if (this.bossType === 'CARRIER') {
                    // å¬å”¤æ— äººæœº
                    if (this.timer % Math.floor(120 * skillInterval) === 0) {
                        entities.enemies.push(new Enemy('drone'));
                        entities.enemies[entities.enemies.length-1].x = this.x;
                        entities.enemies[entities.enemies.length-1].y = this.y;
                    }
                    // ç¯å½¢é˜²å®ˆå¼¹
                    if (this.timer % Math.floor(60 * skillInterval) === 0) {
                         const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                         entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, 'enemy_basic'));
                    }
                    // ç‹‚æš´æ¨¡å¼ï¼šå¬å”¤ç²¾è‹±æ— äººæœº
                    if (this.isEnraged && this.timer % Math.floor(90 * skillInterval) === 0) {
                        entities.enemies.push(new Enemy('elite_drone'));
                        entities.enemies[entities.enemies.length-1].x = this.x;
                        entities.enemies[entities.enemies.length-1].y = this.y;
                    }
                }
                
                // ç§»åŠ¨
                if (this.vx) this.x += this.vx;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Boss é€ å‹
                ctx.shadowBlur = 30;
                if (this.bossType === 'DESTROYER') {
                    ctx.fillStyle = '#ff0000'; ctx.shadowColor='red';
                    ctx.rotate(this.timer * 0.02);
                    ctx.fillRect(-50, -50, 100, 100);
                } else if (this.bossType === 'SPEEDSTER') {
                    ctx.fillStyle = '#ff00ff'; ctx.shadowColor='#ff00ff';
                    ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(50, -30); ctx.lineTo(-50, -30); ctx.fill();
                } else { // CARRIER
                    ctx.fillStyle = '#ff8800'; ctx.shadowColor='#ff8800';
                    ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        // é“å…·
        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; // W(Spread), M(Missile), L(Laser), H(Heal)
                this.active = true; this.vy = 1.5;
                
                const colors = {'W': '#00ffff', 'M': '#ff00ff', 'L': '#4488ff', 'H': '#00ff00'};
                this.color = colors[type];
            }
            update() { this.y += this.vy; if(this.y > height) this.active = false; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fill();
                ctx.strokeStyle = this.color; ctx.lineWidth=3; ctx.stroke();
                ctx.shadowBlur=10; ctx.shadowColor = this.color;
                ctx.fillStyle='white'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(this.type, 0, 1);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
                this.life = 1; this.decay = Math.random()*0.03 + 0.02;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; }
            draw() {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1;
            }
        }

        // --- éšœç¢ç‰©ç±» ---        
        class Obstacle {
            constructor(type, x, y) {
                this.type = type; // meteor, laser, blackhole
                this.x = x; this.y = y;
                this.active = true;
                this.timer = 0;
                
                if (type === 'meteor') {
                    this.radius = Math.random() * 20 + 15;
                    this.vx = (Math.random() - 0.5) * 3;
                    this.vy = Math.random() * 2 + 1;
                    this.hp = 5 + level;
                    this.maxHp = this.hp;
                    this.color = '#886644';
                } else if (type === 'laser') {
                    this.width = width;
                    this.height = 10;
                    this.color = '#ff0000';
                    this.activeTime = 60;
                    this.cooldownTime = 120;
                    this.state = 'active';
                } else if (type === 'blackhole') {
                    this.radius = 40;
                    this.vy = 1;
                    this.pullForce = 0.1;
                    this.color = '#000000';
                }
            }

            update() {
                this.timer++;
                
                if (this.type === 'meteor') {
                    this.x += this.vx;
                    this.y += this.vy;
                    if (this.x < -this.radius || this.x > width + this.radius || this.y > height + this.radius) {
                        this.active = false;
                    }
                } else if (this.type === 'laser') {
                    if (this.state === 'active' && this.timer >= this.activeTime) {
                        this.state = 'cooldown';
                        this.timer = 0;
                    } else if (this.state === 'cooldown' && this.timer >= this.cooldownTime) {
                        this.state = 'active';
                        this.timer = 0;
                    }
                } else if (this.type === 'blackhole') {
                    this.y += this.vy;
                    if (this.y > height + this.radius) {
                        this.active = false;
                    }
                    
                    // å¸å¼•æ•ˆæœ
                    entities.bullets.forEach(b => {
                        if (b.active) {
                            const dx = this.x - b.x;
                            const dy = this.y - b.y;
                            const distance = Math.hypot(dx, dy);
                            if (distance < this.radius * 3) {
                                const force = this.pullForce * (1 - distance / (this.radius * 3));
                                b.vx += (dx / distance) * force;
                                b.vy += (dy / distance) * force;
                            }
                        }
                    });
                    
                    entities.enemies.forEach(e => {
                        if (e.active) {
                            const dx = this.x - e.x;
                            const dy = this.y - e.y;
                            const distance = Math.hypot(dx, dy);
                            if (distance < this.radius * 3) {
                                const force = this.pullForce * 0.5 * (1 - distance / (this.radius * 3));
                                e.x += (dx / distance) * force;
                                e.y += (dy / distance) * force;
                            }
                        }
                    });
                    
                    if (entities.player) {
                        const dx = this.x - entities.player.x;
                        const dy = this.y - entities.player.y;
                        const distance = Math.hypot(dx, dy);
                        if (distance < this.radius * 3) {
                            const force = this.pullForce * 0.3 * (1 - distance / (this.radius * 3));
                            entities.player.x += (dx / distance) * force;
                            entities.player.y += (dy / distance) * force;
                        }
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.type === 'meteor') {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                    
                    // è¡€æ¡
                    if (this.hp < this.maxHp) {
                        ctx.fillStyle = 'red'; ctx.fillRect(-this.radius, -this.radius-10, this.radius*2 * (this.hp/this.maxHp), 3);
                    }
                } else if (this.type === 'laser') {
                    if (this.state === 'active') {
                        ctx.fillStyle = this.color;
                        ctx.shadowBlur = 30; ctx.shadowColor = this.color;
                        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    }
                } else if (this.type === 'blackhole') {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 50; ctx.shadowColor = '#440088';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#440088';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#8844ff';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.4, 0, Math.PI*2); ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // --- è¿·ä½ Bossç±» ---
        class MiniBoss {
            constructor(level) {
                this.active = true;
                this.x = width / 2;
                this.y = -100;
                this.radius = 30;
                this.hp = 100 * level;
                this.maxHp = this.hp;
                this.vx = 0;
                this.vy = 2;
                this.color = '#ff8800';
                this.type = 'mini_boss';
                this.timer = 0;
                this.phase = 'enter';
                
                createFloatText(this.x, this.y, "MINI BOSS APPROACHING!", "#ff8800");
            }

            update() {
                this.timer++;
                
                if (this.phase === 'enter') {
                    this.y += this.vy;
                    if (this.y > 150) {
                        this.phase = 'combat';
                        this.vy = 0;
                    }
                } else if (this.phase === 'combat') {
                    // å·¦å³ç§»åŠ¨
                    this.x = width/2 + Math.sin(this.timer * 0.03) * (width/3);
                    
                    // å°„å‡»
                    if (this.timer % 30 === 0) {
                        for(let i=0; i<3; i++) {
                            const angle = -Math.PI/2 + (i-1)*0.3;
                            entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, 'enemy_basic'));
                        }
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                
                // è¿·ä½ Bossé€ å‹
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(30, 20); ctx.lineTo(0, 10); ctx.lineTo(-30, 20); ctx.fill();
                
                // è¡€æ¡
                ctx.fillStyle = 'red'; ctx.fillRect(-30, -35, 60 * (this.hp/this.maxHp), 4);
                
                ctx.restore();
            }
        }

        // --- æ¸¸æˆæµç¨‹æ§åˆ¶ ---

        function spawnLogic() {
            if (entities.boss) return; // Bossæˆ˜ä¸åˆ·æ€ª

            // Boss å¬å”¤
            if (levelProgress >= CONFIG.bossKillsNeeded) {
                if (!entities.boss && !document.querySelector('.warning-text').offsetParent) {
                    const warning = document.getElementById('warning-msg');
                    warning.style.display = 'block';
                    setTimeout(() => {
                        warning.style.display = 'none';
                        entities.boss = new Boss(level);
                    }, 2500);
                }
                return;
            }

            // è¿·ä½ Bosså¬å”¤
            if (levelProgress === Math.floor(CONFIG.bossKillsNeeded / 2) && !entities.miniBoss) {
                entities.miniBoss = new MiniBoss(level);
            }

            // å°æ€ªç”Ÿæˆ (éš¾åº¦éšç­‰çº§å’Œéš¾åº¦è®¾ç½®å¢åŠ )
            const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
            const spawnRate = Math.floor((60 - Math.min(40, level*5)) * diffSettings.enemySpawnRate);
            if (frameCount % spawnRate === 0) {
                const rand = Math.random();
                let type = 'basic';
                if (rand > 0.7) type = 'shooter';
                else if (rand > 0.4 && level >= 2) type = 'tracker';
                else if (rand > 0.2 && level >= 3) type = 'splitter';
                else if (rand > 0.1 && level >= 4) type = 'shield';
                entities.enemies.push(new Enemy(type));
            }

            // éšœç¢ç‰©ç”Ÿæˆ
            if (level >= 2) {
                // é™¨çŸ³
                if (frameCount % (120 - Math.min(60, level*10)) === 0) {
                    const x = Math.random() * width;
                    entities.obstacles.push(new Obstacle('meteor', x, -50));
                }
                
                // é»‘æ´
                if (level >= 5 && frameCount % 400 === 0) {
                    const x = Math.random() * width;
                    entities.obstacles.push(new Obstacle('blackhole', x, -100));
                }
            }

            // ç‰¹æ®Šäº‹ä»¶
            if (level >= 2) {
                // é“å…·é›¨
                if (frameCount % 600 === 0) {
                    createFloatText(width/2, height/2, "POWER UP RAIN!", "#ffff00");
                    // 30ç§’å†…é“å…·æ‰è½ç‡ç¿»å€
                    setTimeout(() => {
                        createFloatText(width/2, height/2, "POWER UP RAIN ENDED!", "#ff6600");
                    }, 30000);
                }
                
                // æ•Œäººå¢æ´
                if (frameCount % 900 === 0) {
                    createFloatText(width/2, height/2, "ENEMY REINFORCEMENTS!", "#ff0000");
                    // ç”Ÿæˆå¤§é‡æ•Œäºº
                    for(let i=0; i<5; i++) {
                        const enemy = new Enemy('basic');
                        enemy.x = Math.random() * width;
                        enemy.y = -50 - i*20;
                        entities.enemies.push(enemy);
                    }
                }
            }
        }

        function checkCollisions() {
            const p = entities.player;
            
            // å­å¼¹ç¢°æ’
            entities.bullets.forEach(b => {
                if (!b.active) return;
                
                // ç©å®¶æ‰“æ•Œäºº/Boss/è¿·ä½ Boss
                if (b.type === 'spread' || b.type === 'missile' || b.type === 'laser' || b.type === 'flamethrower' || b.type === 'split') {
                    // æ‰“Boss
                    if (entities.boss && entities.boss.active) {
                        if (Math.hypot(b.x - entities.boss.x, b.y - entities.boss.y) < entities.boss.radius + 10) {
                            entities.boss.hp -= b.damage;
                            b.active = (b.type !== 'laser' && b.type !== 'flamethrower'); // æ¿€å…‰å’Œç«ç„°ç©¿é€
                            createExplosion(b.x, b.y, b.type==='spread'?'#00ffff':b.type==='flamethrower'?'#ff8800':b.type==='split'?'#ffff00':'#ff00ff', 3);
                            
                            // æ›´æ–°Bossè¡€æ¡
                            const pct = Math.max(0, (entities.boss.hp / entities.boss.maxHp)*100);
                            document.getElementById('boss-hp').style.width = pct + '%';

                            if (entities.boss.hp <= 0) killBoss();
                        }
                    }
                    
                    // æ‰“è¿·ä½ Boss
                    if (entities.miniBoss && entities.miniBoss.active) {
                        if (Math.hypot(b.x - entities.miniBoss.x, b.y - entities.miniBoss.y) < entities.miniBoss.radius + 10) {
                            entities.miniBoss.hp -= b.damage;
                            b.active = (b.type !== 'laser' && b.type !== 'flamethrower');
                            createExplosion(b.x, b.y, b.type==='spread'?'#00ffff':b.type==='flamethrower'?'#ff8800':b.type==='split'?'#ffff00':'#ff00ff', 3);
                            
                            if (entities.miniBoss.hp <= 0) {
                                entities.miniBoss.active = false;
                                createExplosion(entities.miniBoss.x, entities.miniBoss.y, '#ff8800', 15);
                                score += 1000 * level;
                                gameStats.miniBossesKilled++;
                                createFloatText(entities.miniBoss.x, entities.miniBoss.y, "MINI BOSS DEFEATED!", "#ff8800");
                                entities.miniBoss = null;
                                updateHUD();
                            }
                        }
                    }
                    
                    // æ‰“å°æ€ª
                    entities.enemies.forEach(e => {
                        if (!e.active) return;
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.radius + 10) {
                            e.hp -= b.damage;
                            
                            // åˆ†è£‚å¼¹åˆ†è£‚æ•ˆæœ
                            if (b.type === 'split') {
                                b.active = false;
                                // åˆ†è£‚æˆ3ä¸ªå°å¼¹
                                for(let i=0; i<3; i++) {
                                    const angle = -Math.PI/2 + (i-1)*0.4;
                                    const vx = Math.cos(angle) * 15;
                                    const vy = Math.sin(angle) * 15;
                                    entities.bullets.push(new Bullet(b.x, b.y, vx, vy, 'spread', b.damage / 2));
                                }
                            } else {
                                b.active = (b.type !== 'laser' && b.type !== 'flamethrower');
                            }
                            
                            if (e.hp <= 0) killEnemy(e);
                        }
                    });
                }
                // æ•Œäººæ‰“ç©å®¶
                else if (b.type.startsWith('enemy')) {
                    if (Math.hypot(b.x - p.x, b.y - p.y) < p.radius + 5) {
                        // æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³
                        if (!p.shieldActive) {
                            const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
                            const damage = Math.floor(10 * diffSettings.enemyDamage);
                            p.hp -= damage;
                            b.active = false;
                            shake = 10;
                            createExplosion(p.x, p.y, 'red', 10);
                            checkGameOver();
                        } else {
                            b.active = false;
                            createExplosion(p.x, p.y, '#4488ff', 5);
                            // å¢åŠ æŠ¤ç›¾æŠµæŒ¡ç»Ÿè®¡
                            gameStats.shieldBlocks++;
                        }
                    }
                }
            });

            // ç©å®¶æ’æ•Œäºº
            entities.enemies.forEach(e => {
                if(!e.active) return;
                if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + p.radius) {
                    e.hp = 0; killEnemy(e);
                    if (!p.shieldActive) {
                        const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
                        const damage = Math.floor(15 * diffSettings.enemyDamage);
                        p.hp -= damage;
                        shake = 15;
                        checkGameOver();
                    } else {
                        createExplosion(p.x, p.y, '#4488ff', 8);
                    }
                }
            });

            // åƒé“å…·
            entities.powerups.forEach(pu => {
                if(!pu.active) return;
                if(Math.hypot(pu.x - p.x, pu.y - p.y) < 25) {
                    pu.active = false;
                    // å¢åŠ é“å…·æ”¶é›†ç»Ÿè®¡
                    gameStats.itemsCollected++;
                    if (pu.type === 'H') {
                        p.hp = Math.min(p.maxHp, p.hp + 30);
                        createFloatText(p.x, p.y, "REPAIRED", "#00ff00");
                    } else if (pu.type === 'E') {
                        // èƒ½é‡é“å…· - å¢åŠ EMPä½¿ç”¨æ¬¡æ•°
                        p.empCharges++;
                        createFloatText(p.x, p.y, `EMP CHARGE +1 (${p.empCharges})`, "#8844ff");
                    } else {
                        const map = {'W':'spread', 'M':'missile', 'L':'laser', 'F':'flamethrower', 'T':'time', 'S':'split', 'G':'shield'};
                        const newWep = map[pu.type];
                        
                        // å¦‚æœé“å…·ç±»å‹ä¸åœ¨mapä¸­ï¼Œè·³è¿‡å¤„ç†
                        if (!newWep) {
                            return;
                        }
                        
                        // å…è´¹ä½¿ç”¨15ç§’çš„æ­¦å™¨åˆ—è¡¨
                        const freeUseWeapons = ['missile', 'flamethrower', 'split', 'shield', 'time'];
                        
                        if (p.weapon === newWep) {
                            // æ£€æŸ¥æ˜¯å¦å·²æ»¡çº§
                            if (p.weaponLevel >= 3) {
                                // æ»¡çº§åï¼šä¸´æ—¶å¼ºåŒ– + åˆ†æ•°å¥–åŠ±
                                const bonusScore = 500;
                                score += bonusScore;
                                createFloatText(p.x, p.y, `MAX LEVEL! +${bonusScore} PTS`, "#ffff00");
                                
                                // ä¸´æ—¶å¼ºåŒ–ï¼š10ç§’å†…ä¼¤å®³ç¿»å€
                                p.damageBoost = true;
                                p.damageBoostTimer = 600; // 10ç§’ (60fps)
                                createFloatText(p.x, p.y - 30, "DAMAGE BOOST!", "#ff00ff");
                            } else {
                                // æœªæ»¡çº§ï¼šæ­£å¸¸å‡çº§
                                p.weaponLevel = Math.min(3, p.weaponLevel + 1);
                                p.weaponLevels[newWep] = p.weaponLevel; // æ›´æ–°æ­¦å™¨ç­‰çº§è®°å½•
                                gameStats.weaponsUpgraded++;
                                createFloatText(p.x, p.y, "POWER UP!", "#ffffff");
                            }
                            
                            // ç‰¹å®šæ­¦å™¨æ»¡çº§åä¹Ÿå¯ä»¥å…è´¹ä½¿ç”¨
                            if (freeUseWeapons.includes(newWep)) {
                                p.freeUseTimer = 900; // 15ç§’ (60fps)
                                p.freeUseWeapon = newWep;
                                createFloatText(p.x, p.y - 60, `${p.weapons[newWep].name} FREE 15s!`, "#00ff00");
                            }
                        } else {
                            // åˆ‡æ¢æ­¦å™¨ - ä¿å­˜å½“å‰æ­¦å™¨ç­‰çº§ï¼Œæ¢å¤æ–°æ­¦å™¨ç­‰çº§
                            p.weaponLevels[p.weapon] = p.weaponLevel;
                            p.weapon = newWep;
                            p.weaponLevel = p.weaponLevels[newWep];
                            
                            // å¦‚æœæ–°æ­¦å™¨æœªæ»¡çº§ï¼Œè‡ªåŠ¨å‡çº§
                            if (p.weaponLevel < 3) {
                                p.weaponLevel = Math.min(3, p.weaponLevel + 1);
                                p.weaponLevels[newWep] = p.weaponLevel;
                                gameStats.weaponsUpgraded++;
                                createFloatText(p.x, p.y, `${p.weapons[newWep].name} LV.${p.weaponLevel} AUTO UP!`, p.weapons[newWep].color);
                            } else {
                                createFloatText(p.x, p.y, `${p.weapons[newWep].name} LV.${p.weaponLevel}`, p.weapons[newWep].color);
                            }
                            
                            // ç‰¹å®šæ­¦å™¨å…è´¹ä½¿ç”¨15ç§’
                            if (freeUseWeapons.includes(newWep)) {
                                p.freeUseTimer = 900; // 15ç§’ (60fps)
                                p.freeUseWeapon = newWep;
                                createFloatText(p.x, p.y - 60, `${p.weapons[newWep].name} FREE 15s!`, "#00ff00");
                            }
                        }
                    }
                    updateHUD();
                }
            });

            // éšœç¢ç‰©ç¢°æ’
            entities.obstacles.forEach(obs => {
                if (!obs.active) return;
                
                // ç©å®¶ä¸éšœç¢ç‰©ç¢°æ’
                if (Math.hypot(obs.x - p.x, obs.y - p.y) < (obs.radius || 20) + p.radius) {
                    if (obs.type === 'meteor') {
                        if (!p.shieldActive) {
                            p.hp -= 20;
                            shake = 20;
                            createExplosion(p.x, p.y, 'red', 15);
                            checkGameOver();
                        }
                        obs.hp--;
                        if (obs.hp <= 0) {
                            obs.active = false;
                            createExplosion(obs.x, obs.y, obs.color, 10);
                            score += 50;
                        }
                    } else if (obs.type === 'laser' && obs.state === 'active') {
                        if (!p.shieldActive) {
                            p.hp -= 5;
                            createExplosion(p.x, p.y, 'red', 5);
                            checkGameOver();
                        }
                    }
                }
                
                // æ•Œäººä¸éšœç¢ç‰©ç¢°æ’
                entities.enemies.forEach(e => {
                    if (!e.active) return;
                    if (Math.hypot(obs.x - e.x, obs.y - e.y) < (obs.radius || 20) + e.radius) {
                        if (obs.type === 'meteor') {
                            e.hp -= 10;
                            obs.hp--;
                            createExplosion(e.x, e.y, 'orange', 8);
                            if (e.hp <= 0) killEnemy(e);
                            if (obs.hp <= 0) {
                                obs.active = false;
                                createExplosion(obs.x, obs.y, obs.color, 10);
                                score += 50;
                            }
                        } else if (obs.type === 'laser' && obs.state === 'active') {
                            e.hp -= 2;
                            createExplosion(e.x, e.y, 'red', 5);
                            if (e.hp <= 0) killEnemy(e);
                        }
                    }
                });
                
                // å­å¼¹ä¸éšœç¢ç‰©ç¢°æ’
                entities.bullets.forEach(b => {
                    if (!b.active || b.type.startsWith('enemy')) return;
                    if (Math.hypot(obs.x - b.x, obs.y - b.y) < (obs.radius || 20) + 10) {
                        if (obs.type === 'meteor') {
                            obs.hp -= b.damage;
                            b.active = (b.type === 'laser' || b.type === 'flamethrower');
                            if (obs.hp <= 0) {
                                obs.active = false;
                                createMeteorFragments(obs.x, obs.y);
                                score += 50;
                            }
                        } else if (obs.type === 'blackhole') {
                            b.active = false;
                        }
                    }
                });
            });
            
            // ç ´ç‰‡ç¢°æ’æ£€æµ‹
            if (entities.fragments) {
                entities.fragments.forEach(f => {
                    if (!f.active) return;
                    
                    // ç ´ç‰‡ä¸ç©å®¶ç¢°æ’
                    if (Math.hypot(f.x - p.x, f.y - p.y) < f.radius + p.radius) {
                        if (!p.shieldActive) {
                            p.hp -= f.damage;
                            shake = 10;
                            createExplosion(p.x, p.y, 'red', 8);
                            checkGameOver();
                        }
                        f.active = false;
                    }
                    
                    // ç ´ç‰‡ä¸æ•Œäººç¢°æ’
                    entities.enemies.forEach(e => {
                        if (!e.active) return;
                        if (Math.hypot(f.x - e.x, f.y - e.y) < f.radius + e.radius) {
                            e.hp -= f.damage;
                            f.active = false;
                            createExplosion(e.x, e.y, 'orange', 6);
                            if (e.hp <= 0) killEnemy(e);
                        }
                    });
                });
            }
        }

        // --- è¾…åŠ©å‡½æ•° ---
        function killEnemy(e) {
            // å¤„ç†æŠ¤ç›¾å…µ
            if (e.type === 'shield' && e.shield > 0) {
                e.shield--;
                createExplosion(e.x, e.y, '#4488ff', 5);
                return;
            }
            
            // å¤„ç†åˆ†è£‚è€…
            if (e.type === 'splitter') {
                // åˆ†è£‚æˆä¸¤ä¸ªå°æ•Œäºº
                for(let i=0; i<2; i++) {
                    const smallEnemy = new Enemy('basic');
                    smallEnemy.x = e.x + (Math.random()-0.5)*40;
                    smallEnemy.y = e.y + 20;
                    smallEnemy.hp = e.hp / 4;
                    smallEnemy.radius = 15;
                    entities.enemies.push(smallEnemy);
                }
            }
            
            e.active = false;
            levelProgress++;
            gameStats.enemiesKilled++;
            
            // è¿å‡»ç³»ç»Ÿ
            combo++;
            comboTimer = 60; // 1ç§’è¿å‡»æ—¶é—´
            
            // åˆ†æ•°å€ç‡è®¡ç®—
            if (combo >= 20) scoreMultiplier = 5;
            else if (combo >= 15) scoreMultiplier = 4;
            else if (combo >= 10) scoreMultiplier = 3;
            else if (combo >= 5) scoreMultiplier = 2;
            else scoreMultiplier = 1;
            
            // ç²¾è‹±æ•Œäººåˆ†æ•°åŠ æˆ
            let enemyScore = 20;
            if (e.type === 'shooter') enemyScore = 50;
            if (e.type === 'tracker') enemyScore = 80;
            if (e.type === 'splitter') enemyScore = 100;
            if (e.type === 'shield') enemyScore = 90;
            if (e.type === 'elite_drone') enemyScore = 120;
            
            // åº”ç”¨åˆ†æ•°å€ç‡
            const finalScore = enemyScore * scoreMultiplier;
            score += finalScore;
            
            // è¿å‡»æ–‡å­—
            if (combo >= 5) {
                createFloatText(e.x, e.y, `COMBO ${combo}! x${scoreMultiplier}`, "#ffff00");
            }
            
            createExplosion(e.x, e.y, e.color, 8);
            
            // æ‰è½ç‡æå‡ - æ ¹æ®éš¾åº¦è°ƒæ•´
            const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
            let dropRate = 0.15 * diffSettings.dropRateMultiplier;
            if (e.type === 'tracker' || e.type === 'splitter' || e.type === 'shield' || e.type === 'elite_drone') {
                dropRate = 0.3 * diffSettings.dropRateMultiplier;
            }
            
            // è¿å‡»æå‡æ‰è½ç‡
            if (combo >= 10) {
                dropRate += 0.1;
            }
            
            // æ‰è½
            if (Math.random() < dropRate) {
                // é“å…·æ‰è½åˆ†é…
                const rand = Math.random();
                let type;
                if (rand < 0.35) {
                    type = 'E'; // 35% èƒ½é‡çƒ
                } else if (rand < 0.55) {
                    type = 'P'; // 20% ç”µç£è„‰å†²
                } else {
                    // 45% å…¶ä»–æ­¦å™¨é“å…·
                    const types = ['W', 'M', 'L', 'H'];
                    type = types[Math.floor(Math.random() * types.length)];
                }
                entities.powerups.push(new PowerUp(e.x, e.y, type));
            }
            updateHUD();
        }

        function killBoss() {
            entities.boss.active = false;
            entities.boss = null;
            score += 2000 * level;
            level++;
            levelProgress = 0;
            shake = 30;
            gameStats.bossesKilled++;
            
            // æ¸…å±å¼¹å¹•
            entities.bullets = entities.bullets.filter(b => b.type === 'player');
            
            createExplosion(width/2, height/3, 'white', 100);
            createFloatText(width/2, height/2, "SECTOR CLEARED", "#00ffff");
            document.getElementById('boss-hud').style.display = 'none';
            updateHUD();
        }

        function createExplosion(x, y, color, count) {
            for(let i=0; i<count; i++) entities.particles.push(new Particle(x, y, color, 8));
        }

        function createFloatText(x, y, txt, color) {
            entities.texts.push({x,y,txt,color,life:60});
        }

        function checkGameOver() {
            updateHUD();
            if (entities.player.hp <= 0) {
                gameActive = false;
                // è®¡ç®—æ¸¸æˆæ—¶é•¿
                gameDuration = Math.floor((Date.now() - gameStartTime) / 1000);
                // ä¿å­˜åˆ°æ’è¡Œæ¦œ
                addToLeaderboard(score, currentDifficulty, gameDuration);
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = `æœ€ç»ˆå¾—åˆ†: ${score}`;
                document.getElementById('final-time').innerText = `æ¸¸æˆæ—¶é•¿: ${formatDuration(gameDuration)}`;
            }
        }

        function updateHUD() {
            document.getElementById('score-txt').innerText = `SCORE: ${score}`;
            const themeIndex = Math.min((level - 1), CONFIG.levelThemes.length - 1);
            document.getElementById('level-txt').innerText = `${CONFIG.levelThemes[themeIndex]}`;
            document.getElementById('hp-bar').style.width = (entities.player.hp) + '%';
            document.getElementById('energy-bar').style.width = (entities.player.energy) + '%';
            document.getElementById('weapon-indicator').innerText = `WEAPON: ${entities.player.weapons[entities.player.weapon].name} LV.${entities.player.weaponLevel}`;
            document.getElementById('weapon-indicator').style.color = entities.player.weapons[entities.player.weapon].color;
            
            // EMPæŠ€èƒ½æ˜¾ç¤º
            const empIndicator = document.getElementById('emp-indicator');
            if (empIndicator) {
                if (entities.player.empCharges > 0 || entities.player.empActive) {
                    empIndicator.style.display = 'block';
                    if (entities.player.empActive) {
                        const seconds = Math.ceil(entities.player.empTimer / 60);
                        empIndicator.innerText = `EMP ACTIVE: ${seconds}s`;
                        empIndicator.style.color = '#00ff00';
                    } else {
                        empIndicator.innerText = `EMP: ${entities.player.empCharges} (Press E)`;
                        empIndicator.style.color = '#8844ff';
                    }
                } else {
                    empIndicator.style.display = 'none';
                }
            }
            
            // è¿å‡»æ˜¾ç¤º
            const comboDisplay = document.getElementById('combo-display');
            if (combo > 0) {
                comboDisplay.innerText = `COMBO x${combo}`;
                comboDisplay.style.display = 'block';
                // è¿å‡»é¢œè‰²æ¸å˜
                if (combo >= 20) {
                    comboDisplay.style.color = '#ff00ff';
                    comboDisplay.style.textShadow = '0 0 30px #ff00ff';
                } else if (combo >= 15) {
                    comboDisplay.style.color = '#00ffff';
                    comboDisplay.style.textShadow = '0 0 25px #00ffff';
                } else if (combo >= 10) {
                    comboDisplay.style.color = '#00ff00';
                    comboDisplay.style.textShadow = '0 0 20px #00ff00';
                } else {
                    comboDisplay.style.color = '#ffff00';
                    comboDisplay.style.textShadow = '0 0 15px #ffff00';
                }
            } else {
                comboDisplay.style.display = 'none';
            }
        }

        // --- æ’è¡Œæ¦œç³»ç»Ÿ ---
        
        // åŠ è½½æ’è¡Œæ¦œ
        function loadLeaderboard() {
            try {
                const saved = localStorage.getItem(LEADERBOARD_KEY);
                if (saved) {
                    leaderboard = JSON.parse(saved);
                }
            } catch (e) {
                console.log('æ— æ³•åŠ è½½æ’è¡Œæ¦œ:', e);
                leaderboard = [];
            }
        }
        
        // ä¿å­˜æ’è¡Œæ¦œ
        function saveLeaderboard() {
            try {
                localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
            } catch (e) {
                console.log('æ— æ³•ä¿å­˜æ’è¡Œæ¦œ:', e);
            }
        }
        
        // æ ¼å¼åŒ–æ¸¸æˆæ—¶é•¿
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // æ·»åŠ åˆ†æ•°åˆ°æ’è¡Œæ¦œ
        function addToLeaderboard(finalScore, difficulty, duration) {
            const entry = {
                score: finalScore,
                difficulty: difficulty,
                duration: duration,
                date: new Date().toLocaleDateString()
            };
            
            leaderboard.push(entry);
            
            // æŒ‰åˆ†æ•°æ’åº
            leaderboard.sort((a, b) => b.score - a.score);
            
            // ç¡®ä¿å„éš¾åº¦è‡³å°‘æœ‰3æ¡è®°å½•
            const difficulties = ['easy', 'normal', 'hard'];
            const entriesToKeep = [];
            const entriesByDifficulty = {
                'easy': [],
                'normal': [],
                'hard': []
            };
            
            // æŒ‰éš¾åº¦åˆ†ç±»
            leaderboard.forEach(entry => {
                if (entriesByDifficulty[entry.difficulty]) {
                    entriesByDifficulty[entry.difficulty].push(entry);
                }
            });
            
            // ä¸ºæ¯ä¸ªéš¾åº¦ä¿ç•™è‡³å°‘3æ¡
            difficulties.forEach(diff => {
                const diffEntries = entriesByDifficulty[diff];
                // å–è¯¥éš¾åº¦çš„å‰3æ¡ï¼ˆæˆ–å…¨éƒ¨å¦‚æœä¸è¶³3æ¡ï¼‰
                const toKeep = diffEntries.slice(0, Math.max(MIN_ENTRIES_PER_DIFFICULTY, diffEntries.length));
                entriesToKeep.push(...toKeep);
            });
            
            // æ·»åŠ å…¶ä»–é«˜åˆ†é…é¢
            const remainingSlots = MAX_LEADERBOARD_ENTRIES - entriesToKeep.length;
            if (remainingSlots > 0) {
                // è·å–ä¸åœ¨å·²ä¿ç•™åˆ—è¡¨ä¸­çš„å…¶ä»–è®°å½•
                const otherEntries = leaderboard.filter(entry => 
                    !entriesToKeep.includes(entry)
                );
                entriesToKeep.push(...otherEntries.slice(0, remainingSlots));
            }
            
            // é‡æ–°æ’åºå¹¶æˆªæ–­
            leaderboard = entriesToKeep.sort((a, b) => b.score - a.score).slice(0, MAX_LEADERBOARD_ENTRIES);
            
            saveLeaderboard();
        }
        
        // æ˜¾ç¤ºæ’è¡Œæ¦œ
        function showLeaderboard() {
            const leaderboardDiv = document.getElementById('leaderboard-screen');
            const listDiv = document.getElementById('leaderboard-list');
            
            if (!leaderboardDiv || !listDiv) return;
            
            // ç”Ÿæˆæ’è¡Œæ¦œHTML
            let html = '<table style="width:100%; border-collapse:collapse; font-size:14px;">';
            html += '<tr style="background:rgba(0,255,255,0.2);">';
            html += '<th style="padding:10px; border:1px solid #00ffff;">æ’å</th>';
            html += '<th style="padding:10px; border:1px solid #00ffff;">åˆ†æ•°</th>';
            html += '<th style="padding:10px; border:1px solid #00ffff;">éš¾åº¦</th>';
            html += '<th style="padding:10px; border:1px solid #00ffff;">æ—¶é•¿</th>';
            html += '<th style="padding:10px; border:1px solid #00ffff;">æ—¥æœŸ</th>';
            html += '</tr>';
            
            const difficultyNames = {
                'easy': 'ç®€å•',
                'normal': 'æ™®é€š',
                'hard': 'å›°éš¾'
            };
            
            const difficultyColors = {
                'easy': '#00ff00',
                'normal': '#ffff00',
                'hard': '#ff0000'
            };
            
            leaderboard.forEach((entry, index) => {
                const rankColor = index < 3 ? '#ffd700' : '#ffffff';
                const diffColor = difficultyColors[entry.difficulty] || '#ffffff';
                html += `<tr style="background:${index % 2 === 0 ? 'rgba(0,0,0,0.3)' : 'rgba(0,0,0,0.5)'}">`;
                html += `<td style="padding:8px; border:1px solid #00ffff; color:${rankColor}; font-weight:bold;">${index + 1}</td>`;
                html += `<td style="padding:8px; border:1px solid #00ffff; color:#00ffff;">${entry.score}</td>`;
                html += `<td style="padding:8px; border:1px solid #00ffff; color:${diffColor};">${difficultyNames[entry.difficulty] || entry.difficulty}</td>`;
                html += `<td style="padding:8px; border:1px solid #00ffff;">${formatDuration(entry.duration)}</td>`;
                html += `<td style="padding:8px; border:1px solid #00ffff;">${entry.date}</td>`;
                html += '</tr>';
            });
            
            html += '</table>';
            
            if (leaderboard.length === 0) {
                html = '<div style="text-align:center; padding:50px; color:#888;">æš‚æ— è®°å½•</div>';
            }
            
            listDiv.innerHTML = html;
            leaderboardDiv.classList.remove('hidden');
        }
        
        // æ˜¾ç¤ºæˆå°±åˆ—è¡¨
        function showAchievements() {
            const achievementsDiv = document.getElementById('achievements-screen');
            const listDiv = document.getElementById('achievements-list');
            
            if (!achievementsDiv || !listDiv) return;
            
            // ç”Ÿæˆæˆå°±HTML
            let html = '<div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">';
            
            ACHIEVEMENTS.forEach(achievement => {
                const isUnlocked = achievement.unlocked;
                const bgColor = isUnlocked ? 'rgba(255,215,0,0.1)' : 'rgba(100,100,100,0.2)';
                const borderColor = isUnlocked ? '#ffd700' : '#666';
                const textColor = isUnlocked ? '#fff' : '#888';
                const icon = isUnlocked ? 'ğŸ†' : 'ğŸ”’';
                const statusText = isUnlocked ? 'å·²è§£é”' : 'æœªè§£é”';
                
                html += `<div style="background:${bgColor}; border:2px solid ${borderColor}; border-radius:10px; padding:15px;">`;
                html += `<div style="display:flex; align-items:center; gap:10px; margin-bottom:8px;">`;
                html += `<span style="font-size:24px;">${icon}</span>`;
                html += `<span style="font-weight:bold; color:${isUnlocked ? '#ffd700' : '#aaa'}; font-size:16px;">${achievement.name}</span>`;
                html += `</div>`;
                html += `<div style="color:${textColor}; font-size:14px; margin-bottom:5px;">${achievement.description}</div>`;
                html += `<div style="color:${isUnlocked ? '#00ff00' : '#666'}; font-size:12px;">${statusText}</div>`;
                html += `</div>`;
            });
            
            html += '</div>';
            
            // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
            const unlockedCount = ACHIEVEMENTS.filter(a => a.unlocked).length;
            const totalCount = ACHIEVEMENTS.length;
            html += `<div style="text-align:center; margin-top:20px; padding:15px; background:rgba(0,255,255,0.1); border-radius:10px;">`;
            html += `<span style="color:#00ffff; font-size:18px;">æˆå°±è¿›åº¦: ${unlockedCount}/${totalCount}</span>`;
            html += `<div style="width:100%; height:10px; background:rgba(255,255,255,0.1); border-radius:5px; margin-top:10px;">`;
            html += `<div style="width:${(unlockedCount/totalCount)*100}%; height:100%; background:linear-gradient(90deg, #ffd700, #ffaa00); border-radius:5px; transition:width 0.5s;"></div>`;
            html += `</div></div>`;
            
            listDiv.innerHTML = html;
            achievementsDiv.classList.remove('hidden');
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        function loop() {
            if (!gameActive) return;
            requestAnimationFrame(loop);
            frameCount++;

            // èƒŒæ™¯æ¸…ç† (å«éœ‡åŠ¨)
            ctx.save();
            if (shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9;
                if(shake < 1) shake = 0;
            }
            
            // åŠ¨æ€èƒŒæ™¯è‰²
            const bgIdx = (level - 1) % 3;
            const bgC = CONFIG.bgColors[bgIdx];
            ctx.fillStyle = `rgba(${bgC.r}, ${bgC.g}, ${bgC.b}, 0.4)`;
            ctx.fillRect(-50, -50, width+100, height+100);

            // æ˜Ÿæ˜Ÿ
            entities.stars.forEach(s => {
                s.y += s.speed + (level * 0.5);
                if (s.y > height) { s.y = 0; s.x = Math.random() * width; }
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });

            // é€»è¾‘æ›´æ–°
            entities.player.update();
            if (entities.boss) entities.boss.update();
            if (entities.miniBoss) entities.miniBoss.update();
            spawnLogic();
            
            // è¿å‡»ç³»ç»Ÿæ›´æ–°
            if (comboTimer > 0) {
                comboTimer--;
            } else if (combo > 0) {
                // è¿å‡»é‡ç½® - æ˜¾ç¤ºåœ¨å·¦ä¸Šè§’
                createFloatText(100, 150, `COMBO ENDED! ${combo} hits`, "#ff6600");
                combo = 0;
                scoreMultiplier = 1;
            }
            
            // æ›´æ–°æ¸¸æˆçŠ¶æ€
            gameStats.survivalTime = (Date.now() - gameStats.startTime) / 1000;
            gameStats.maxCombo = Math.max(gameStats.maxCombo, combo);
            gameStats.highScore = Math.max(gameStats.highScore, score);
            gameStats.maxLevel = Math.max(gameStats.maxLevel, level);
            
            // æ£€æµ‹æˆå°±
            checkAchievements();
            
            // æ‰¹é‡æ›´æ–°
            ['bullets', 'enemies', 'powerups', 'particles', 'obstacles'].forEach(key => {
                entities[key].forEach(e => e.update());
                entities[key] = entities[key].filter(e => e.active || e.life > 0);
            });
            
            // æ›´æ–°ç ´ç‰‡
            if (entities.fragments) {
                entities.fragments.forEach(f => f.update());
                entities.fragments = entities.fragments.filter(f => f.active);
            }

            checkCollisions();

            // ç»˜åˆ¶
            entities.stars.forEach(s => {}); // å·²ç»˜
            entities.obstacles.forEach(e => e.draw());
            entities.powerups.forEach(e => e.draw());
            if (entities.boss) entities.boss.draw();
            if (entities.miniBoss) entities.miniBoss.draw();
            entities.enemies.forEach(e => e.draw());
            entities.player.draw();
            entities.bullets.forEach(e => e.draw());
            entities.particles.forEach(e => e.draw());
            
            // ç»˜åˆ¶ç ´ç‰‡
            if (entities.fragments) {
                entities.fragments.forEach(f => f.draw());
            }

            // æµ®åŠ¨æ–‡å­—
            entities.texts.forEach((t, i) => {
                ctx.fillStyle = t.color; ctx.font = "bold 20px Arial";
                ctx.fillText(t.txt, t.x - ctx.measureText(t.txt).width/2, t.y);
                t.y -= 1; t.life--;
                if(t.life <= 0) entities.texts.splice(i, 1);
            });

            ctx.restore();
        }

        // --- å¯åŠ¨é€»è¾‘ ---
        // æˆå°±ç³»ç»Ÿå‡½æ•°
        function initAchievements() {
            achievements = ACHIEVEMENTS.map(a => ({...a, unlocked: false}));
            unlockedAchievements = [];
        }

        function checkAchievements() {
            achievements.forEach(achievement => {
                if (!achievement.unlocked && achievement.condition(gameStats)) {
                    achievement.unlocked = true;
                    unlockedAchievements.push(achievement);
                    // æ˜¾ç¤ºæˆå°±è§£é”é€šçŸ¥
                    createAchievementNotification(achievement);
                }
            });
        }

        function createAchievementNotification(achievement) {
            // æˆå°±æç¤ºæ˜¾ç¤ºåœ¨å·¦ä¸Šè§’
            createFloatText(120, 200, `ğŸ† æˆå°±è§£é”: ${achievement.name}`, "#ffff00");
            createFloatText(120, 230, achievement.description, "#ffffff");
        }

        function init() {
            entities = { player: new Player(), bullets: [], enemies: [], particles: [], powerups: [], boss: null, miniBoss: null, texts: [], stars: [], obstacles: [] };
            // ç”Ÿæˆæ˜Ÿæ˜Ÿ
            for(let i=0; i<100; i++) entities.stars.push({
                x: Math.random()*width, y: Math.random()*height,
                size: Math.random()*2, speed: Math.random()*2+0.5, alpha: Math.random()
            });
            
            score = 0; level = 1; levelProgress = 0;
            combo = 0; comboTimer = 0; scoreMultiplier = 1;
            gameStartTime = Date.now(); // è®°å½•æ¸¸æˆå¼€å§‹æ—¶é—´
            gameStats = {
                enemiesKilled: 0,
                maxCombo: 0,
                bossesKilled: 0,
                miniBossesKilled: 0,
                weaponsUpgraded: 0,
                highScore: 0,
                maxLevel: 0,
                survivalTime: 0,
                startTime: Date.now()
            };
            initAchievements();
            gameActive = true;
            document.getElementById('boss-hud').style.display = 'none';
            updateHUD();
        }

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('start-screen').classList.add('hidden');
            init(); loop();
        };
        document.getElementById('restart-btn').onclick = () => {
            document.getElementById('game-over-screen').classList.add('hidden');
            init(); loop();
        };
        
        // æ’è¡Œæ¦œæŒ‰é’®äº‹ä»¶
        document.getElementById('leaderboard-btn-start').onclick = () => {
            loadLeaderboard();
            showLeaderboard();
        };
        document.getElementById('leaderboard-btn-gameover').onclick = () => {
            loadLeaderboard();
            showLeaderboard();
        };
        document.getElementById('leaderboard-back-btn').onclick = () => {
            document.getElementById('leaderboard-screen').classList.add('hidden');
        };
        document.getElementById('leaderboard-clear-btn').onclick = () => {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ’è¡Œæ¦œè®°å½•å—ï¼Ÿ')) {
                leaderboard = [];
                saveLeaderboard();
                showLeaderboard();
            }
        };
        
        // æˆå°±æŒ‰é’®äº‹ä»¶
        document.getElementById('achievements-btn-start').onclick = () => {
            showAchievements();
        };
        document.getElementById('achievements-back-btn').onclick = () => {
            document.getElementById('achievements-screen').classList.add('hidden');
        };
        
        // å…¥å‘æŒ‡å—æŒ‰é’®äº‹ä»¶
        document.getElementById('guide-btn-start').onclick = () => {
            document.getElementById('guide-screen').classList.remove('hidden');
        };
        document.getElementById('guide-back-btn').onclick = () => {
            document.getElementById('guide-screen').classList.add('hidden');
        };
        document.getElementById('guide-start-btn').onclick = () => {
            document.getElementById('guide-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.add('hidden');
            init(); loop();
        };
        
        // æ–°æ‰‹å¼•å¯¼æŒ‰é’®äº‹ä»¶
        document.getElementById('tutorial-guide-btn').onclick = () => {
            document.getElementById('tutorial-screen').classList.add('hidden');
            document.getElementById('guide-screen').classList.remove('hidden');
            // æ ‡è®°å·²çœ‹è¿‡å¼•å¯¼
            localStorage.setItem('spaceShooterTutorialSeen', 'true');
        };
        document.getElementById('tutorial-start-btn').onclick = () => {
            document.getElementById('tutorial-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.add('hidden');
            init(); loop();
            // æ ‡è®°å·²çœ‹è¿‡å¼•å¯¼
            localStorage.setItem('spaceShooterTutorialSeen', 'true');
        };
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡ç©
        function checkFirstTime() {
            const hasSeenTutorial = localStorage.getItem('spaceShooterTutorialSeen');
            if (!hasSeenTutorial) {
                // æ˜¾ç¤ºæ–°æ‰‹å¼•å¯¼
                document.getElementById('tutorial-screen').classList.remove('hidden');
            }
        }
        
        // åˆå§‹åŒ–æ—¶åŠ è½½æ’è¡Œæ¦œå’Œæ£€æŸ¥æ–°æ‰‹å¼•å¯¼
        loadLeaderboard();
        checkFirstTime();

    </script>
</body>
</html>
