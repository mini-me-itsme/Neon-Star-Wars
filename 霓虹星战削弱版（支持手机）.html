<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星际霓虹：终极进化版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
        }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* HUD 样式 */
        .top-bar {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            font-weight: 900;
            text-shadow: 0 0 10px currentColor;
            font-size: 20px;
        }
        .hud-item { display: flex; flex-direction: column; align-items: center; }
        .bar-frame {
            width: 200px; height: 16px;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5);
            margin-top: 5px;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
        }
        .fill-bar { height: 100%; transition: width 0.1s; }
        
        #boss-hud {
            position: absolute; top: 80px; width: 100%;
            display: none; align-items: center; flex-direction: column;
        }
        #boss-name { font-size: 28px; color: #ff0055; text-shadow: 0 0 15px red; letter-spacing: 5px; margin-bottom: 5px; }

        /* 武器指示器 */
        #weapon-indicator {
            position: absolute; bottom: 30px; left: 30px;
            font-size: 24px; font-weight: bold;
            text-shadow: 0 0 10px cyan;
        }

        /* 屏幕文字 */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        h1 {
            font-size: 60px; margin: 0 0 20px;
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-transform: uppercase; letter-spacing: 5px;
        }
        button {
            background: transparent; color: #00ffff;
            border: 2px solid #00ffff;
            padding: 15px 50px; font-size: 24px;
            cursor: pointer; transition: 0.3s;
            text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 15px #00ffff;
        }
        button:hover { background: #00ffff; color: black; transform: scale(1.1); }
        .hidden { display: none !important; }
        
        /* 提示动画 */
        @keyframes flash { 0%{opacity:1} 50%{opacity:0.2} 100%{opacity:1} }
        .warning-text { 
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 100px; color: #ff0000; font-weight: 900;
            animation: flash 0.3s infinite; display: none; letter-spacing: 20px;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="hud-item" style="color:#00ffff; align-items: flex-start;">
                <div id="score-txt">SCORE: 0</div>
                <div id="level-txt" style="font-size:14px; opacity:0.8">SECTOR 1</div>
            </div>
            <div class="hud-item">
                <div style="color: #00ff00">SHIELD INTEGRITY</div>
                <div class="bar-frame"><div id="hp-bar" class="fill-bar" style="width:100%; background:#00ff00; box-shadow: 0 0 10px #00ff00;"></div></div>
            </div>
        </div>

        <div id="boss-hud">
            <div id="boss-name">WARNING</div>
            <div class="bar-frame" style="width: 60%; height: 20px; border-color: #ff0055;">
                <div id="boss-hp" class="fill-bar" style="width: 100%; background: #ff0055; box-shadow: 0 0 20px #ff0055;"></div>
            </div>
        </div>

        <div id="weapon-indicator">WEAPON: SPREAD</div>
        <div id="warning-msg" class="warning-text">WARNING</div>

        <div id="start-screen" class="screen-overlay">
            <h1>星际霓虹<span style="font-size:30px; display:block; text-align:center; letter-spacing:10px; margin-top:10px; color:white; -webkit-text-fill-color:white;">终极进化</span></h1>
            <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; margin-bottom:40px; text-align:center;">
                <div><span style="color:#00ffff; font-size:30px;">●</span><br>散弹 (W)</div>
                <div><span style="color:#ff00ff; font-size:30px;">●</span><br>导弹 (M)</div>
                <div><span style="color:#4488ff; font-size:30px;">●</span><br>激光 (L)</div>
            </div>
            <button id="start-btn">启动引擎</button>
        </div>

        <div id="game-over-screen" class="screen-overlay hidden">
            <h1 style="background:none; -webkit-text-fill-color:red; color:red; text-shadow: 0 0 30px red;">通讯中断</h1>
            <p id="final-score" style="font-size:30px; margin-bottom:40px;">最终得分: 0</p>
            <button id="restart-btn">重启系统</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // --- 核心变量 ---
        let width, height;
        let gameActive = false;
        let score = 0, level = 1, frameCount = 0;
        let entities = { player: null, bullets: [], enemies: [], particles: [], powerups: [], boss: null, texts: [], stars: [] };
        const mouse = { x: 0, y: 0 };
        
        // 配置参数
        const CONFIG = {
            bossKillsNeeded: 30, // 多少击杀出Boss
            bgColors: [
                {r:0, g:10, b:20},   // Lv1 深蓝
                {r:20, g:0, b:20},   // Lv2 深紫
                {r:20, g:5, b:5}     // Lv3 深红
            ]
        };
        let levelProgress = 0;
        let shake = 0;

        // --- 初始化与事件 ---
        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
        }
        window.onresize = resize; resize();
        window.onmousemove = e => { mouse.x = e.clientX; mouse.y = e.clientY; };
        window.ontouchmove = e => { e.preventDefault(); mouse.x = e.touches[0].clientX; mouse.y = e.touches[0].clientY; };

        // --- 实体类定义 ---

        class Player {
            constructor() {
                this.x = width/2; this.y = height - 100;
                this.radius = 18;
                this.hp = 100; this.maxHp = 100;
                this.color = '#00ffff';
                
                // 武器系统
                this.weapon = 'spread'; // spread, missile, laser
                this.weaponLevel = 1;
                this.lastShot = 0;
                
                // 武器配置
                this.weapons = {
                    'spread': { delay: 10, color: '#00ffff', name: 'PULSE SPREAD' },
                    'missile': { delay: 25, color: '#ff00ff', name: 'HOMING MISSILE' },
                    'laser': { delay: 6, color: '#4488ff', name: 'HYPER BEAM' }
                };
            }

            update() {
                // 移动
                this.x += (mouse.x - this.x) * 0.15;
                this.y += (mouse.y - this.y) * 0.15;
                this.x = Math.max(this.radius, Math.min(width-this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(height-this.radius, this.y));

                // 射击
                const wConfig = this.weapons[this.weapon];
                if (frameCount - this.lastShot > wConfig.delay) {
                    this.fire(this.weapon);
                    this.lastShot = frameCount;
                }
            }

            fire(type) {
                const y = this.y - 25;
                if (type === 'spread') {
                    entities.bullets.push(new Bullet(this.x, y, 0, -18, type));
                    if (this.weaponLevel >= 2) {
                        entities.bullets.push(new Bullet(this.x, y, -3, -16, type));
                        entities.bullets.push(new Bullet(this.x, y, 3, -16, type));
                    }
                    if (this.weaponLevel >= 3) {
                        entities.bullets.push(new Bullet(this.x, y, -6, -14, type));
                        entities.bullets.push(new Bullet(this.x, y, 6, -14, type));
                    }
                } else if (type === 'missile') {
                    // 寻找最近敌人
                    let count = this.weaponLevel * 2; // Lv1: 2发, Lv2: 4发
                    for(let i=0; i<count; i++) {
                        const angle = -Math.PI/2 + (Math.random()-0.5);
                        const vx = Math.cos(angle) * 5;
                        const vy = Math.sin(angle) * 5;
                        entities.bullets.push(new Bullet(this.x, y, vx, vy, type));
                    }
                } else if (type === 'laser') {
                    // 极速直线弹
                    const damage = 3 * this.weaponLevel; // 伤害随等级
                    entities.bullets.push(new Bullet(this.x, y, 0, -30, type, damage));
                    if (this.weaponLevel >= 2) {
                        entities.bullets.push(new Bullet(this.x - 15, y + 10, 0, -30, type, damage));
                        entities.bullets.push(new Bullet(this.x + 15, y + 10, 0, -30, type, damage));
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // 尾焰
                ctx.fillStyle = `rgba(0, 255, 255, ${Math.random()})`;
                ctx.beginPath(); ctx.moveTo(-8, 15); ctx.lineTo(0, 35 + Math.random()*20); ctx.lineTo(8, 15); ctx.fill();

                // 机体
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -25); ctx.lineTo(20, 20); ctx.lineTo(0, 10); ctx.lineTo(-20, 20);
                ctx.fill();

                // 护盾圈
                if (frameCount % 60 < 30) {
                    ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0,this.radius+5,0,Math.PI*2); ctx.stroke();
                }
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, vx, vy, type, dmgOverride) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.type = type; // spread, missile, laser, enemy_basic, enemy_laser
                this.active = true;
                this.target = null; // for missile
                this.damage = dmgOverride || 1;
                
                if (type === 'missile') this.damage = 3;
                if (type.startsWith('enemy')) this.damage = 10;
            }

            update() {
                if (this.type === 'missile') {
                    // 导弹制导逻辑
                    if (!this.target || !this.target.active) {
                        // 寻找新目标
                        let closest = null;
                        let minDist = 1000;
                        const targets = entities.boss ? [entities.boss] : entities.enemies;
                        
                        targets.forEach(e => {
                            if (!e.active) return;
                            const d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d < minDist) { minDist = d; closest = e; }
                        });
                        this.target = closest;
                    }

                    if (this.target) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        // 惯性转向
                        this.vx += Math.cos(angle) * 1;
                        this.vy += Math.sin(angle) * 1;
                        // 速度限制
                        const speed = Math.hypot(this.vx, this.vy);
                        if(speed > 12) { this.vx *= 0.95; this.vy *= 0.95; }
                    } else {
                        this.vy -= 0.5; // 无目标向上加速
                    }
                } 

                this.x += this.vx;
                this.y += this.vy;

                // 粒子拖尾
                if (this.type === 'missile' && frameCount % 3 === 0) {
                    entities.particles.push(new Particle(this.x, this.y, '#ff00ff', 0.5));
                }

                if (this.x < -50 || this.x > width + 50 || this.y < -50 || this.y > height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 10;
                
                if (this.type === 'spread') {
                    ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.arc(0,0,5,0,Math.PI*2); ctx.fill();
                } else if (this.type === 'missile') {
                    ctx.rotate(Math.atan2(this.vy, this.vx) + Math.PI/2);
                    ctx.fillStyle = '#ff00ff'; ctx.fillRect(-3, -8, 6, 16);
                } else if (this.type === 'laser') {
                    ctx.fillStyle = '#4488ff'; ctx.shadowColor='#4488ff';
                    ctx.fillRect(-3, -20, 6, 40);
                } else if (this.type.startsWith('enemy')) {
                    ctx.fillStyle = '#ff0000'; ctx.shadowColor='red';
                    ctx.beginPath(); ctx.arc(0,0,6,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class Enemy {
            constructor(type) {
                this.x = Math.random() * (width - 40) + 20;
                this.y = -50;
                this.type = type; // basic, shooter, drone
                this.active = true;
                this.hp = 3 + (level * 1.5);
                this.radius = 20;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = Math.random() * 2 + 2 + (level * 0.2);
                this.color = '#ff3333';
                this.maxHp = this.hp;
                
                if (type === 'shooter') {
                    this.color = '#cc00ff'; this.vy = 1.5; this.hp *= 1.5;
                }
                if (type === 'drone') {
                    this.color = '#ffaa00'; this.radius = 12; this.hp = 1; this.vy = 5;
                }
            }

            update() {
                this.x += this.vx; this.y += this.vy;
                if (this.x < 0 || this.x > width) this.vx *= -1;

                // 射击逻辑
                if (this.type === 'shooter' && Math.random() < 0.015) {
                    const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                    entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*6, Math.sin(angle)*6, 'enemy_basic'));
                }

                if (this.y > height + 50) this.active = false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                
                if (this.type === 'basic') {
                    ctx.beginPath(); ctx.moveTo(0,15); ctx.lineTo(15,-15); ctx.lineTo(-15,-15); ctx.fill();
                } else if (this.type === 'shooter') {
                    ctx.rotate(frameCount * 0.05);
                    ctx.fillRect(-12,-12,24,24);
                } else if (this.type === 'drone') {
                    ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
                }
                
                // 简易血条
                if(this.hp < this.maxHp) {
                    ctx.fillStyle = 'red'; ctx.fillRect(-15, -25, 30 * (this.hp/this.maxHp), 3);
                }
                ctx.restore();
            }
        }

        // --- Boss 逻辑 ---
        class Boss {
            constructor(level) {
                this.active = true;
                this.x = width / 2; this.y = -150;
                this.radius = 70;
                this.maxHp = 300 * level;
                this.hp = this.maxHp;
                this.phase = 'enter';
                this.timer = 0;
                this.level = level;
                
                // Boss 类型配置
                const types = ['DESTROYER', 'SPEEDSTER', 'CARRIER'];
                this.bossType = types[(level - 1) % 3];
                
                // 名字显示
                document.getElementById('boss-name').innerText = `⚠️ ${this.bossType} ⚠️`;
                document.getElementById('boss-hud').style.display = 'flex';
            }

            update() {
                this.timer++;

                // 入场
                if (this.phase === 'enter') {
                    this.y += 1.5;
                    if (this.y > 150) this.phase = 'combat';
                    return;
                }

                // 通用移动
                if (this.bossType === 'SPEEDSTER') {
                    // 快速左右冲刺
                    this.x = width/2 + Math.sin(this.timer * 0.05) * (width/2 - 50);
                } else {
                    // 缓慢移动
                    this.x = width/2 + Math.sin(this.timer * 0.02) * (width/3);
                }

                // 技能释放
                if (this.bossType === 'DESTROYER') {
                    // 弹幕地狱
                    if (this.timer % 10 === 0) { // 螺旋弹
                        const angle = this.timer * 0.1;
                        for(let i=0; i<4; i++) {
                            const a = angle + (Math.PI/2)*i;
                            entities.bullets.push(new Bullet(this.x, this.y, Math.cos(a)*4, Math.sin(a)*4, 'enemy_basic'));
                        }
                    }
                } 
                else if (this.bossType === 'SPEEDSTER') {
                    // 激光连射
                    if (this.timer % 90 === 0) {
                        for(let i=-2; i<=2; i++) {
                             entities.bullets.push(new Bullet(this.x, this.y + 40, i*2, 8, 'enemy_laser'));
                        }
                    }
                }
                else if (this.bossType === 'CARRIER') {
                    // 召唤无人机
                    if (this.timer % 120 === 0) {
                        entities.enemies.push(new Enemy('drone'));
                        entities.enemies[entities.enemies.length-1].x = this.x;
                        entities.enemies[entities.enemies.length-1].y = this.y;
                    }
                    // 环形防守弹
                    if (this.timer % 60 === 0) {
                         const angle = Math.atan2(entities.player.y - this.y, entities.player.x - this.x);
                         entities.bullets.push(new Bullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, 'enemy_basic'));
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Boss 造型
                ctx.shadowBlur = 30;
                if (this.bossType === 'DESTROYER') {
                    ctx.fillStyle = '#ff0000'; ctx.shadowColor='red';
                    ctx.rotate(this.timer * 0.02);
                    ctx.fillRect(-50, -50, 100, 100);
                } else if (this.bossType === 'SPEEDSTER') {
                    ctx.fillStyle = '#ff00ff'; ctx.shadowColor='#ff00ff';
                    ctx.beginPath(); ctx.moveTo(0, 50); ctx.lineTo(50, -30); ctx.lineTo(-50, -30); ctx.fill();
                } else { // CARRIER
                    ctx.fillStyle = '#ff8800'; ctx.shadowColor='#ff8800';
                    ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
            }
        }

        // 道具
        class PowerUp {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; // W(Spread), M(Missile), L(Laser), H(Heal)
                this.active = true; this.vy = 1.5;
                
                const colors = {'W': '#00ffff', 'M': '#ff00ff', 'L': '#4488ff', 'H': '#00ff00'};
                this.color = colors[type];
            }
            update() { this.y += this.vy; if(this.y > height) this.active = false; }
            draw() {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fill();
                ctx.strokeStyle = this.color; ctx.lineWidth=3; ctx.stroke();
                ctx.shadowBlur=10; ctx.shadowColor = this.color;
                ctx.fillStyle='white'; ctx.font='bold 16px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(this.type, 0, 1);
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color, speed) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random()-0.5)*speed; this.vy = (Math.random()-0.5)*speed;
                this.life = 1; this.decay = Math.random()*0.03 + 0.02;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=this.decay; }
            draw() {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1;
            }
        }

        // --- 游戏流程控制 ---

        function spawnLogic() {
            if (entities.boss) return; // Boss战不刷怪

            // Boss 召唤
            if (levelProgress >= CONFIG.bossKillsNeeded) {
                if (!entities.boss && !document.querySelector('.warning-text').offsetParent) {
                    const warning = document.getElementById('warning-msg');
                    warning.style.display = 'block';
                    setTimeout(() => {
                        warning.style.display = 'none';
                        entities.boss = new Boss(level);
                    }, 2500);
                }
                return;
            }

            // 小怪生成 (难度随等级增加)
            if (frameCount % (60 - Math.min(40, level*5)) === 0) {
                const rand = Math.random();
                let type = 'basic';
                if (rand > 0.7) type = 'shooter';
                entities.enemies.push(new Enemy(type));
            }
        }

        function checkCollisions() {
            const p = entities.player;
            
            // 子弹碰撞
            entities.bullets.forEach(b => {
                if (!b.active) return;
                
                // 玩家打敌人/Boss
                if (b.type === 'spread' || b.type === 'missile' || b.type === 'laser') {
                    // 打Boss
                    if (entities.boss && entities.boss.active) {
                        if (Math.hypot(b.x - entities.boss.x, b.y - entities.boss.y) < entities.boss.radius + 10) {
                            entities.boss.hp -= b.damage;
                            b.active = (b.type !== 'laser'); // 激光穿透
                            createExplosion(b.x, b.y, b.type==='spread'?'#00ffff':'#ff00ff', 3);
                            
                            // 更新Boss血条
                            const pct = Math.max(0, (entities.boss.hp / entities.boss.maxHp)*100);
                            document.getElementById('boss-hp').style.width = pct + '%';

                            if (entities.boss.hp <= 0) killBoss();
                        }
                    }
                    // 打小怪
                    entities.enemies.forEach(e => {
                        if (!e.active) return;
                        if (Math.hypot(b.x - e.x, b.y - e.y) < e.radius + 10) {
                            e.hp -= b.damage;
                            b.active = (b.type !== 'laser');
                            if (e.hp <= 0) killEnemy(e);
                        }
                    });
                }
                // 敌人打玩家
                else if (b.type.startsWith('enemy')) {
                    if (Math.hypot(b.x - p.x, b.y - p.y) < p.radius + 5) {
                        p.hp -= 10;
                        b.active = false;
                        shake = 10;
                        createExplosion(p.x, p.y, 'red', 10);
                        checkGameOver();
                    }
                }
            });

            // 玩家撞敌人
            entities.enemies.forEach(e => {
                if(!e.active) return;
                if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + p.radius) {
                    e.hp = 0; killEnemy(e);
                    p.hp -= 15;
                    shake = 15;
                    checkGameOver();
                }
            });

            // 吃道具
            entities.powerups.forEach(pu => {
                if(!pu.active) return;
                if(Math.hypot(pu.x - p.x, pu.y - p.y) < 25) {
                    pu.active = false;
                    if (pu.type === 'H') {
                        p.hp = Math.min(p.maxHp, p.hp + 30);
                        createFloatText(p.x, p.y, "REPAIRED", "#00ff00");
                    } else {
                        const map = {'W':'spread', 'M':'missile', 'L':'laser'};
                        const newWep = map[pu.type];
                        if (p.weapon === newWep) {
                            p.weaponLevel = Math.min(3, p.weaponLevel + 1);
                            createFloatText(p.x, p.y, "POWER UP!", "#ffffff");
                        } else {
                            p.weapon = newWep;
                            p.weaponLevel = 1;
                            createFloatText(p.x, p.y, p.weapons[newWep].name, p.weapons[newWep].color);
                        }
                    }
                    updateHUD();
                }
            });
        }

        // --- 辅助函数 ---
        function killEnemy(e) {
            e.active = false;
            levelProgress++;
            score += (e.type==='shooter'?50:20);
            createExplosion(e.x, e.y, e.color, 8);
            
            // 掉落
            if (Math.random() < 0.15) {
                const types = ['W', 'M', 'L', 'H'];
                const type = types[Math.floor(Math.random() * types.length)];
                entities.powerups.push(new PowerUp(e.x, e.y, type));
            }
            updateHUD();
        }

        function killBoss() {
            entities.boss.active = false;
            entities.boss = null;
            score += 2000 * level;
            level++;
            levelProgress = 0;
            shake = 30;
            
            // 清屏弹幕
            entities.bullets = entities.bullets.filter(b => b.type === 'player');
            
            createExplosion(width/2, height/3, 'white', 100);
            createFloatText(width/2, height/2, "SECTOR CLEARED", "#00ffff");
            document.getElementById('boss-hud').style.display = 'none';
            updateHUD();
        }

        function createExplosion(x, y, color, count) {
            for(let i=0; i<count; i++) entities.particles.push(new Particle(x, y, color, 8));
        }

        function createFloatText(x, y, txt, color) {
            entities.texts.push({x,y,txt,color,life:60});
        }

        function checkGameOver() {
            updateHUD();
            if (entities.player.hp <= 0) {
                gameActive = false;
                document.getElementById('game-over-screen').classList.remove('hidden');
                document.getElementById('final-score').innerText = `最终得分: ${score}`;
            }
        }

        function updateHUD() {
            document.getElementById('score-txt').innerText = `SCORE: ${score}`;
            document.getElementById('level-txt').innerText = `SECTOR ${level}`;
            document.getElementById('hp-bar').style.width = (entities.player.hp) + '%';
            document.getElementById('weapon-indicator').innerText = `WEAPON: ${entities.player.weapons[entities.player.weapon].name} LV.${entities.player.weaponLevel}`;
            document.getElementById('weapon-indicator').style.color = entities.player.weapons[entities.player.weapon].color;
        }

        // --- 渲染循环 ---
        function loop() {
            if (!gameActive) return;
            requestAnimationFrame(loop);
            frameCount++;

            // 背景清理 (含震动)
            ctx.save();
            if (shake > 0) {
                ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
                shake *= 0.9;
                if(shake < 1) shake = 0;
            }
            
            // 动态背景色
            const bgIdx = (level - 1) % 3;
            const bgC = CONFIG.bgColors[bgIdx];
            ctx.fillStyle = `rgba(${bgC.r}, ${bgC.g}, ${bgC.b}, 0.4)`;
            ctx.fillRect(-50, -50, width+100, height+100);

            // 星星
            entities.stars.forEach(s => {
                s.y += s.speed + (level * 0.5);
                if (s.y > height) { s.y = 0; s.x = Math.random() * width; }
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });

            // 逻辑更新
            entities.player.update();
            if (entities.boss) entities.boss.update();
            spawnLogic();
            
            // 批量更新
            ['bullets', 'enemies', 'powerups', 'particles'].forEach(key => {
                entities[key].forEach(e => e.update());
                entities[key] = entities[key].filter(e => e.active || e.life > 0);
            });

            checkCollisions();

            // 绘制
            entities.stars.forEach(s => {}); // 已绘
            entities.powerups.forEach(e => e.draw());
            if (entities.boss) entities.boss.draw();
            entities.enemies.forEach(e => e.draw());
            entities.player.draw();
            entities.bullets.forEach(e => e.draw());
            entities.particles.forEach(e => e.draw());

            // 浮动文字
            entities.texts.forEach((t, i) => {
                ctx.fillStyle = t.color; ctx.font = "bold 20px Arial";
                ctx.fillText(t.txt, t.x - ctx.measureText(t.txt).width/2, t.y);
                t.y -= 1; t.life--;
                if(t.life <= 0) entities.texts.splice(i, 1);
            });

            ctx.restore();
        }

        // --- 启动逻辑 ---
        function init() {
            entities = { player: new Player(), bullets: [], enemies: [], particles: [], powerups: [], boss: null, texts: [], stars: [] };
            // 生成星星
            for(let i=0; i<100; i++) entities.stars.push({
                x: Math.random()*width, y: Math.random()*height,
                size: Math.random()*2, speed: Math.random()*2+0.5, alpha: Math.random()
            });
            
            score = 0; level = 1; levelProgress = 0;
            gameActive = true;
            document.getElementById('boss-hud').style.display = 'none';
            updateHUD();
        }

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('start-screen').classList.add('hidden');
            init(); loop();
        };
        document.getElementById('restart-btn').onclick = () => {
            document.getElementById('game-over-screen').classList.add('hidden');
            init(); loop();
        };

    </script>
</body>
</html>